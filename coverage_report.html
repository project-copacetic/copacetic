
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>connhelpers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/project-copacetic/copacetic/pkg/buildkit/connhelpers/buildx.go (35.1%)</option>
				
				<option value="file1">github.com/project-copacetic/copacetic/pkg/buildkit/connhelpers/docker.go (60.0%)</option>
				
				<option value="file2">github.com/project-copacetic/copacetic/pkg/common/buildkit.go (15.0%)</option>
				
				<option value="file3">github.com/project-copacetic/copacetic/pkg/common/os.go (100.0%)</option>
				
				<option value="file4">github.com/project-copacetic/copacetic/pkg/common/progress.go (77.8%)</option>
				
				<option value="file5">github.com/project-copacetic/copacetic/pkg/common/tag.go (100.0%)</option>
				
				<option value="file6">github.com/project-copacetic/copacetic/pkg/imageloader/docker.go (92.1%)</option>
				
				<option value="file7">github.com/project-copacetic/copacetic/pkg/imageloader/loader.go (91.7%)</option>
				
				<option value="file8">github.com/project-copacetic/copacetic/pkg/imageloader/podman.go (100.0%)</option>
				
				<option value="file9">github.com/project-copacetic/copacetic/pkg/patch/build.go (60.7%)</option>
				
				<option value="file10">github.com/project-copacetic/copacetic/pkg/patch/cmd.go (88.5%)</option>
				
				<option value="file11">github.com/project-copacetic/copacetic/pkg/patch/core.go (0.0%)</option>
				
				<option value="file12">github.com/project-copacetic/copacetic/pkg/patch/loader.go (20.0%)</option>
				
				<option value="file13">github.com/project-copacetic/copacetic/pkg/patch/manifest.go (0.0%)</option>
				
				<option value="file14">github.com/project-copacetic/copacetic/pkg/patch/multi.go (43.0%)</option>
				
				<option value="file15">github.com/project-copacetic/copacetic/pkg/patch/patch.go (30.6%)</option>
				
				<option value="file16">github.com/project-copacetic/copacetic/pkg/patch/platform.go (75.4%)</option>
				
				<option value="file17">github.com/project-copacetic/copacetic/pkg/patch/single.go (48.9%)</option>
				
				<option value="file18">github.com/project-copacetic/copacetic/pkg/pkgmgr/apk.go (85.1%)</option>
				
				<option value="file19">github.com/project-copacetic/copacetic/pkg/pkgmgr/dpkg.go (40.5%)</option>
				
				<option value="file20">github.com/project-copacetic/copacetic/pkg/pkgmgr/pkgmgr.go (36.4%)</option>
				
				<option value="file21">github.com/project-copacetic/copacetic/pkg/pkgmgr/rpm.go (62.6%)</option>
				
				<option value="file22">github.com/project-copacetic/copacetic/pkg/report/report.go (51.4%)</option>
				
				<option value="file23">github.com/project-copacetic/copacetic/pkg/report/trivy.go (84.6%)</option>
				
				<option value="file24">github.com/project-copacetic/copacetic/pkg/test_utils/utils.go (71.4%)</option>
				
				<option value="file25">github.com/project-copacetic/copacetic/pkg/types/v1alpha1/convert.go (100.0%)</option>
				
				<option value="file26">github.com/project-copacetic/copacetic/pkg/utils/eol.go (87.2%)</option>
				
				<option value="file27">github.com/project-copacetic/copacetic/pkg/utils/log.go (100.0%)</option>
				
				<option value="file28">github.com/project-copacetic/copacetic/pkg/utils/mediatype.go (52.1%)</option>
				
				<option value="file29">github.com/project-copacetic/copacetic/pkg/utils/utils.go (15.4%)</option>
				
				<option value="file30">github.com/project-copacetic/copacetic/pkg/vex/openvex.go (92.6%)</option>
				
				<option value="file31">github.com/project-copacetic/copacetic/pkg/vex/vex.go (88.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package connhelpers

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/rand"
        "net"
        "net/url"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/cpuguy83/dockercfg"
        "github.com/cpuguy83/go-docker"
        "github.com/cpuguy83/go-docker/container"
        "github.com/cpuguy83/go-docker/errdefs"
        "github.com/moby/buildkit/client/connhelper"
        log "github.com/sirupsen/logrus"
)

func init() <span class="cov1" title="1">{
        connhelper.Register("buildx", Buildx)
}</span>

type buildxConfig struct {
        Driver string
        Nodes  []struct {
                Name     string
                Endpoint string
        }
}

// Buildx returns a buildkit connection helper for connecting to a buildx instance.
// Only "docker-container" buildkit instances are currently supported.
// If there are multiple nodes configured, one will be chosen at random.
func Buildx(u *url.URL) (*connhelper.ConnectionHelper, error) <span class="cov10" title="3">{
        if u.Path != "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("buildx driver does not support path elements: %s", u.Path)
        }</span>
        <span class="cov6" title="2">return &amp;connhelper.ConnectionHelper{
                ContextDialer: buildxContextDialer(u.Host),
        }, nil</span>
}

func supportsDialStio(ctx context.Context) bool <span class="cov6" title="2">{
        cmd := exec.CommandContext(ctx, "docker", "buildx", "dial-stdio", "--help")
        return cmd.Run() == nil
}</span>

// buildxDialStdio uses the buildx dial-stdio command to connect to a buildx instance.
//
// The way this works is it uses the buildx CLI as a proxy to connect to the buildx instance.
// The connection is proxied over the stdin/stdout of the buildx CLI.
//
// This allows us to support any buildx instance, even if it is not running in a container.
func buildxDialStdio(ctx context.Context, builder string) (net.Conn, error) <span class="cov1" title="1">{
        cmd := exec.CommandContext(ctx, "docker", "buildx", "dial-stdio", "--progress=plain")
        if builder != "" </span><span class="cov0" title="0">{
                cmd.Args = append(cmd.Args, "--builder", builder)
        }</span>
        <span class="cov1" title="1">cmd.Env = os.Environ()

        c1, c2 := net.Pipe()
        cmd.Stdin = c1
        cmd.Stdout = c1

        // Use a pipe to check when the connection is actually complete
        // Also write all of stderr to an error buffer so we can have more details
        // in the error message when the command fails.
        r, w := io.Pipe()
        errBuf := bytes.NewBuffer(nil)
        ww := io.MultiWriter(w, errBuf)
        cmd.Stderr = ww

        if err := cmd.Start(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err := cmd.Wait()
                c1.Close()
                // pkgerrors.Wrap will return nil if err is nil, otherwise it will give
                // us a wrapped error with the buffered stderr from he command.
                w.CloseWithError(fmt.Errorf("%s: %s", err, errBuf))
        }</span>()

        <span class="cov0" title="0">defer r.Close()

        scanner := bufio.NewScanner(r)
        for scanner.Scan() </span><span class="cov0" title="0">{
                txt := strings.ToLower(scanner.Text())

                if strings.HasPrefix(txt, "#1 dialing builder") &amp;&amp; strings.HasSuffix(txt, "done") </span><span class="cov0" title="0">{
                        go func() </span><span class="cov0" title="0">{
                                // Continue draining stderr so the process does not get blocked
                                _, _ = io.Copy(io.Discard, r)
                        }</span>()
                        <span class="cov0" title="0">break</span>
                }
        }
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c2, nil</span>
}

func buildxContextDialer(builder string) func(context.Context, string) (net.Conn, error) <span class="cov6" title="2">{
        return func(ctx context.Context, _ string) (net.Conn, error) </span><span class="cov0" title="0">{
                if supportsDialStio(ctx) </span><span class="cov0" title="0">{
                        return buildxDialStdio(ctx, builder)
                }</span>

                <span class="cov0" title="0">configPath, err := dockercfg.ConfigPath()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if builder == "" </span><span class="cov0" title="0">{
                        // Standard env for setting a buildx builder name to use
                        // This is used by buildx so we should use it too.
                        builder = os.Getenv("BUILDX_BUILDER")
                }</span>

                <span class="cov0" title="0">base := filepath.Join(filepath.Dir(configPath), "buildx")
                if builder == "" </span><span class="cov0" title="0">{
                        dt, err := os.ReadFile(filepath.Join(base, "current"))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">type ref struct {
                                Name string `json:"name"`
                        }
                        var r ref
                        if err := json.Unmarshal(dt, &amp;r); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("could not unmarshal buildx config: %w", err)
                        }</span>
                        <span class="cov0" title="0">builder = r.Name</span>
                }

                // Note: buildx inspect does not return json here, so we can't use the output directly
                <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "docker", "buildx", "inspect", "--bootstrap", builder)
                errBuf := bytes.NewBuffer(nil)
                cmd.Stderr = errBuf
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not inspect buildx instance: %w: %s", err, errBuf.String())
                }</span>

                // Read the config from the buildx instance
                <span class="cov0" title="0">dt, err := os.ReadFile(filepath.Join(base, "instances", builder))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var cfg buildxConfig
                if err := json.Unmarshal(dt, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("could not unmarshal buildx instance config: %w", err)
                }</span>

                <span class="cov0" title="0">if cfg.Driver != "docker-container" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unsupported buildx driver: %s", cfg.Driver)
                }</span>

                <span class="cov0" title="0">if len(cfg.Nodes) == 0 </span><span class="cov0" title="0">{
                        return nil, errors.New("no nodes configured for buildx instance")
                }</span>

                <span class="cov0" title="0">log.WithFields(log.Fields{
                        "driver":   cfg.Driver,
                        "endpoint": cfg.Nodes[0].Endpoint,
                        "name":     cfg.Nodes[0].Name,
                }).Debug("Connect to buildx instance")

                nodes := cfg.Nodes
                if len(nodes) &gt; 1 </span><span class="cov0" title="0">{
                        rand.Shuffle(len(nodes), func(i, j int) </span><span class="cov0" title="0">{
                                nodes[i], nodes[j] = nodes[j], nodes[i]
                        }</span>)
                }
                <span class="cov0" title="0">return containerContextDialer(ctx, nodes[0].Endpoint, "buildx_buildkit_"+nodes[0].Name)</span>
        }
}

func containerContextDialer(ctx context.Context, host, name string) (net.Conn, error) <span class="cov10" title="3">{
        tr, err := getDockerTransport(host)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="2">cli := docker.NewClient(docker.WithTransport(tr))
        c := cli.ContainerService().NewContainer(ctx, name)

        conn1, conn2 := net.Pipe()
        ep, err := c.Exec(ctx, container.WithExecCmd("buildctl", "dial-stdio"), func(cfg *container.ExecConfig) </span><span class="cov6" title="2">{
                cfg.Stdin = conn1
                cfg.Stdout = conn1
                cfg.Stderr = conn1
        }</span>)
        <span class="cov6" title="2">if err != nil </span><span class="cov6" title="2">{
                if errdefs.IsNotFound(err) </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("could not find container %s: %w", name, err)
                }</span>
                <span class="cov1" title="1">if err2 := c.Start(ctx); err2 != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ep, err = c.Exec(ctx, container.WithExecCmd("buildctl", "dial-stdio"), func(cfg *container.ExecConfig) </span><span class="cov0" title="0">{
                        cfg.Stdin = conn1
                        cfg.Stdout = conn1
                        cfg.Stderr = conn1
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := ep.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not start exec proxy: %w", err)
        }</span>

        <span class="cov0" title="0">return conn2, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package connhelpers

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/url"
        "os"
        "os/exec"
        "path"
        "strings"

        "github.com/cpuguy83/go-docker/transport"
        "github.com/cpuguy83/go-docker/version"
        "github.com/moby/buildkit/client/connhelper"
        log "github.com/sirupsen/logrus"
)

func init() <span class="cov1" title="1">{
        connhelper.Register("docker", Docker)
}</span>

// Docker returns a buildkit connection helper for connecting to a docker daemon.
func Docker(u *url.URL) (*connhelper.ConnectionHelper, error) <span class="cov1" title="1">{
        return &amp;connhelper.ConnectionHelper{
                ContextDialer: func(ctx context.Context, _ string) (net.Conn, error) </span><span class="cov0" title="0">{
                        tr, err := getDockerTransport(path.Join(u.Host, u.Path))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return tr.DoRaw(ctx, http.MethodPost, version.Join(ctx, "/grpc"), transport.WithUpgrade("h2c"))</span>
                },
        }, nil
}

func getDockerTransport(addr string) (transport.Doer, error) <span class="cov10" title="6">{
        if addr == "" </span><span class="cov1" title="1">{
                addr = os.Getenv("DOCKER_HOST")
        }</span>
        <span class="cov10" title="6">if addr == "" </span><span class="cov0" title="0">{
                var err error
                addr, err = AddrFromDockerContext()
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errNoDockerContext) </span><span class="cov0" title="0">{
                                return transport.DefaultTransport()
                        }</span>
                        <span class="cov0" title="0">return nil, fmt.Errorf("error getting docker context: %w", err)</span>
                }
        }

        <span class="cov10" title="6">if !strings.Contains(addr, ":/") </span><span class="cov0" title="0">{
                // This is probably a docker context name
                var err error
                addr, err = addrFromContext(addr)
                if err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).WithField("docker context", addr).Debug("Error getting docker context, assuming connection string")
                }</span>
        }
        <span class="cov10" title="6">return transport.FromConnectionString(addr)</span>
}

var errNoDockerContext = fmt.Errorf("no docker context found")

func addrFromContext(name string) (string, error) <span class="cov1" title="1">{
        cmd := exec.Command("docker", "context", "inspect", name, "--format", "{{.Endpoints.docker.Host}}")

        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                out := string(out)
                return "", fmt.Errorf("error inspecting docker context %q: %w: %s", name, err, out)
        }</span>

        <span class="cov1" title="1">addr := strings.TrimSpace(string(out))
        return addr, nil</span>
}

func AddrFromDockerContext() (_ string, retErr error) <span class="cov6" title="3">{
        if v := os.Getenv("DOCKER_CONTEXT"); v != "" </span><span class="cov1" title="1">{
                // context is defiend in the env, no need to scan for it
                return addrFromContext(v)
        }</span>

        <span class="cov4" title="2">cmd := exec.Command("docker", "context", "ls", "--format", "json")

        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating stdout pipe: %w", err)
        }</span>
        <span class="cov4" title="2">defer stdout.Close()

        stderr := bytes.NewBuffer((nil))
        cmd.Stderr = stderr

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error starting docker context ls: %w", err)
        }</span>

        <span class="cov4" title="2">defer func() </span><span class="cov4" title="2">{
                err := cmd.Wait()
                if retErr == nil </span><span class="cov4" title="2">{
                        retErr = err
                        return
                }</span>
                <span class="cov0" title="0">retErr = fmt.Errorf("%w: %w: %s", err, retErr, stderr)</span>
        }()

        <span class="cov4" title="2">type contextEntry struct {
                Endpoint string `json:"DockerEndpoint"`
                Current  bool   `json:"Current"`
        }

        var entry contextEntry

        dec := json.NewDecoder(stdout)
        for </span><span class="cov6" title="3">{
                if err := dec.Decode(&amp;entry); err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                return "", errNoDockerContext
                        }</span>
                        <span class="cov0" title="0">return "", fmt.Errorf("error decoding docker context ls output: %w", err)</span>
                }

                <span class="cov6" title="3">if entry.Current </span><span class="cov4" title="2">{
                        return entry.Endpoint, nil
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

import (
        "context"
        "fmt"

        "github.com/containerd/platforms"
        gwclient "github.com/moby/buildkit/frontend/gateway/client"
        ispec "github.com/opencontainers/image-spec/specs-go/v1"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/pkgmgr"
)

const (
        LINUX = "linux"
)

// SetupBuildkitConfigAndManager initializes buildkit config and package manager.
// This combines the common pattern used in both generate and patch commands.
func SetupBuildkitConfigAndManager(
        ctx context.Context,
        c gwclient.Client,
        image string,
        platform *ispec.Platform,
        workingFolder string,
        osInfo *OSInfo, // If nil, will be detected from image
) (*buildkit.Config, pkgmgr.PackageManager, error) <span class="cov0" title="0">{
        // Initialize buildkit config
        config, err := buildkit.InitializeBuildkitConfig(ctx, c, image, platform)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">var manager pkgmgr.PackageManager
        if osInfo == nil </span><span class="cov0" title="0">{
                // Need to determine OS from image
                fileBytes, err := buildkit.ExtractFileFromState(ctx, c, &amp;config.ImageState, "/etc/os-release")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("unable to extract /etc/os-release file from state %w", err)
                }</span>

                <span class="cov0" title="0">detectedOSInfo, err := GetOSInfo(ctx, fileBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">osInfo = detectedOSInfo</span>
        }

        // Get package manager based on OS type
        <span class="cov0" title="0">manager, err = pkgmgr.GetPackageManager(osInfo.Type, osInfo.Version, config, workingFolder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return config, manager, nil</span>
}

// GetDefaultLinuxPlatform returns a normalized Linux platform, defaulting to Linux if not already Linux.
func GetDefaultLinuxPlatform() ispec.Platform <span class="cov10" title="2">{
        platform := platforms.Normalize(platforms.DefaultSpec())
        if platform.OS != LINUX </span><span class="cov0" title="0">{
                platform.OS = LINUX
        }</span>
        <span class="cov10" title="2">return platform</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package common

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/quay/claircore/osrelease"
        log "github.com/sirupsen/logrus"
)

// OSInfo contains the OS type and version information.
type OSInfo struct {
        Type    string
        Version string
}

// GetOSInfo extracts OS type and version from os-release data.
func GetOSInfo(ctx context.Context, osreleaseBytes []byte) (*OSInfo, error) <span class="cov10" title="32">{
        r := bytes.NewReader(osreleaseBytes)
        osData, err := osrelease.Parse(ctx, r)
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("unable to parse os-release data %w", err)
        }</span>

        <span class="cov9" title="30">osType := strings.ToLower(osData["NAME"])
        var normalizedType string
        switch </span>{
        case strings.Contains(osType, "alpine"):<span class="cov3" title="3">
                normalizedType = "alpine"</span>
        case strings.Contains(osType, "debian"):<span class="cov4" title="4">
                normalizedType = "debian"</span>
        case strings.Contains(osType, "ubuntu"):<span class="cov2" title="2">
                normalizedType = "ubuntu"</span>
        case strings.Contains(osType, "amazon"):<span class="cov2" title="2">
                normalizedType = "amazon"</span>
        case strings.Contains(osType, "centos"):<span class="cov2" title="2">
                normalizedType = "centos"</span>
        case strings.Contains(osType, "mariner"):<span class="cov3" title="3">
                normalizedType = "cbl-mariner"</span>
        case strings.Contains(osType, "azure linux"):<span class="cov2" title="2">
                normalizedType = "azurelinux"</span>
        case strings.Contains(osType, "red hat"):<span class="cov2" title="2">
                normalizedType = "redhat"</span>
        case strings.Contains(osType, "rocky"):<span class="cov2" title="2">
                normalizedType = "rocky"</span>
        case strings.Contains(osType, "oracle"):<span class="cov3" title="3">
                normalizedType = "oracle"</span>
        case strings.Contains(osType, "alma"):<span class="cov2" title="2">
                normalizedType = "alma"</span>
        default:<span class="cov3" title="3">
                log.Error("unsupported osType ", osType)
                return nil, errors.ErrUnsupported</span>
        }

        <span class="cov9" title="27">return &amp;OSInfo{
                Type:    normalizedType,
                Version: osData["VERSION_ID"],
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package common

import (
        "context"
        "os"

        "github.com/moby/buildkit/client"
        "github.com/moby/buildkit/util/progress/progressui"
        log "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"
)

// DisplayProgress starts a goroutine to display build progress.
// This encapsulates the common pattern used in both generate and patch commands.
func DisplayProgress(ctx context.Context, eg *errgroup.Group, buildChannel chan *client.SolveStatus, progress progressui.DisplayMode) <span class="cov10" title="2">{
        eg.Go(func() error </span><span class="cov10" title="2">{
                // Display progress
                mode := progress
                if log.GetLevel() &gt;= log.DebugLevel </span><span class="cov0" title="0">{
                        mode = progressui.PlainMode
                }</span>
                <span class="cov10" title="2">display, err := progressui.NewDisplay(os.Stderr, mode)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov10" title="2">_, err = display.UpdateFrom(ctx, buildChannel)
                return err</span>
        })
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package common

import (
        "fmt"

        "github.com/distribution/reference"
)

// ResolvePatchedTag merges explicit tag &amp; suffix rules, returning the final patched tag.
func ResolvePatchedTag(imageRef reference.Named, explicitTag, suffix string) (string, error) <span class="cov10" title="10">{
        // if user explicitly sets a final tag, that wins outright
        if explicitTag != "" </span><span class="cov3" title="2">{
                return explicitTag, nil
        }</span>

        // parse out any existing tag from the image ref
        <span class="cov9" title="8">var baseTag string
        if tagged, ok := imageRef.(reference.Tagged); ok </span><span class="cov8" title="6">{
                baseTag = tagged.Tag()
        }</span>

        // if suffix is empty, default to "patched"
        <span class="cov9" title="8">if suffix == "" </span><span class="cov1" title="1">{
                suffix = "patched"
        }</span>

        // if we have no original baseTag (the user's image had no tag),
        // then we can't append a suffix to it
        <span class="cov9" title="8">if baseTag == "" </span><span class="cov3" title="2">{
                return "", fmt.Errorf("no tag found in image reference %s", imageRef.String())
        }</span>

        // otherwise, combine them
        <span class="cov8" title="6">return fmt.Sprintf("%s-%s", baseTag, suffix), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package imageloader

import (
        "bufio"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "os"

        dockerTypes "github.com/docker/docker/api/types"
        "github.com/docker/docker/api/types/image"
        dockerClient "github.com/docker/docker/client"
        "github.com/project-copacetic/copacetic/pkg/buildkit/connhelpers"
        log "github.com/sirupsen/logrus"
)

// dockerAPIClient defines the interface for Docker client operations needed by dockerLoader.
// This allows for easier mocking in tests.
type dockerAPIClient interface {
        Ping(ctx context.Context) (dockerTypes.Ping, error)
        ImageLoad(ctx context.Context, input io.Reader, loadOpts ...dockerClient.ImageLoadOption) (image.LoadResponse, error)
}

type dockerLoader struct{ cli dockerAPIClient }

func probeDocker(ctx context.Context) (Loader, bool) <span class="cov5" title="3">{
        hostOpt := func(c *dockerClient.Client) error </span><span class="cov5" title="3">{
                if os.Getenv(dockerClient.EnvOverrideHost) != "" </span><span class="cov3" title="2">{
                        // Fallback to just keep dockerClient.FromEnv whatever was set from
                        return nil
                }</span>
                <span class="cov1" title="1">addr, err := connhelpers.AddrFromDockerContext()
                if err != nil </span><span class="cov0" title="0">{
                        log.WithError(err).Error("Error loading docker context, falling back to env")
                        return nil
                }</span>
                <span class="cov1" title="1">return dockerClient.WithHost(addr)(c)</span>
        }
        <span class="cov5" title="3">cli, err := dockerClient.NewClientWithOpts(
                dockerClient.FromEnv,
                hostOpt,
                dockerClient.WithAPIVersionNegotiation(),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov5" title="3">if _, err = cli.Ping(ctx); err != nil </span><span class="cov3" title="2">{
                return nil, false
        }</span>
        <span class="cov1" title="1">return &amp;dockerLoader{cli: cli}, true</span>
}

// Load streams the tarball into either Docker or Podman.
func (d *dockerLoader) Load(ctx context.Context, tar io.Reader, _ string) error <span class="cov10" title="9">{
        log.Debug("Loading image stream using Docker API client")
        resp, err := d.cli.ImageLoad(ctx, tar, dockerClient.ImageLoadWithQuiet(false))
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("docker ImageLoad: %w", err)
        }</span>
        <span class="cov9" title="8">defer resp.Body.Close()

        scanner := bufio.NewScanner(resp.Body)
        lastLine := ""
        for scanner.Scan() </span><span class="cov8" title="7">{
                line := scanner.Text()
                lastLine = line
                log.Debugf("ImageLoad response stream: %s", line)
        }</span>
        <span class="cov9" title="8">if err := scanner.Err(); err != nil </span><span class="cov1" title="1">{
                log.Warnf("error reading ImageLoad response: %v", err)
        }</span>

        <span class="cov9" title="8">if resp.JSON &amp;&amp; lastLine != "" </span><span class="cov6" title="4">{
                var jsonResp struct {
                        ErrorResponse *dockerTypes.ErrorResponse `json:"errorResponse"`
                        Error         string                     `json:"error"`
                }
                if err := json.Unmarshal([]byte(lastLine), &amp;jsonResp); err == nil </span><span class="cov5" title="3">{
                        switch </span>{
                        case jsonResp.ErrorResponse != nil:<span class="cov1" title="1">
                                return fmt.Errorf("ImageLoad error: %s", jsonResp.ErrorResponse.Message)</span>
                        case jsonResp.Error != "":<span class="cov1" title="1">
                                return fmt.Errorf("ImageLoad error: %s", jsonResp.Error)</span>
                        }
                } else<span class="cov1" title="1"> {
                        log.Debugf("final ImageLoad line (non-JSON): %s", lastLine)
                }</span>
        } else<span class="cov6" title="4"> if lastLine != "" </span><span class="cov1" title="1">{
                log.Debugf("final ImageLoad line (non-JSON): %s", lastLine)
        }</span>

        <span class="cov8" title="6">log.Info("image loaded successfully via Docker API")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package imageloader

import (
        "context"
        "fmt"
        "io"
)

// Loader type constants.
const (
        Docker = "docker"
        Podman = "podman"
)

// Loader streams an OCI/Docker tar archive into a local container engine.
type Loader interface {
        Load(ctx context.Context, tar io.Reader, imageRef string) error
}

// Config is the configuration for the image loader.
// It specifies which container engine to use for loading images.
type Config struct {
        // Docker | Podman | ""
        Loader string
}

// New instantiates the concrete loader.
func New(ctx context.Context, cfg Config) (Loader, error) <span class="cov10" title="7">{
        switch cfg.Loader </span>{
        case Docker, "":<span class="cov6" title="3">
                if l, ok := probeDocker(ctx); ok </span><span class="cov1" title="1">{
                        return l, nil
                }</span>
                <span class="cov4" title="2">if cfg.Loader == Docker </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("docker socket not reachable")
                }</span>
                <span class="cov1" title="1">fallthrough</span>
        case Podman:<span class="cov7" title="4">
                if l, ok := probePodman(ctx); ok </span><span class="cov6" title="3">{
                        return l, nil
                }</span>
                <span class="cov1" title="1">if cfg.Loader == Podman </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("podman socket not reachable")
                }</span>
                <span class="cov0" title="0">fallthrough</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unknown loader %q", cfg.Loader)</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package imageloader

import (
        "context"
        "fmt"
        "io"
        "os/exec"
        "strings"

        log "github.com/sirupsen/logrus"
)

type podmanLoader struct{}

// probePodman now just checks the CLI is available.
func probePodman(_ context.Context) (Loader, bool) <span class="cov10" title="4">{
        if _, err := exec.LookPath("podman"); err != nil </span><span class="cov1" title="1">{
                log.Debug("podman CLI not found in $PATH")
                return nil, false
        }</span>
        <span class="cov8" title="3">return &amp;podmanLoader{}, true</span>
}

// Load streams the tar straight into `podman load` via stdin.
func (p *podmanLoader) Load(ctx context.Context, tar io.Reader, _ string) error <span class="cov5" title="2">{
        log.Debug("Loading image stream using podman CLI")
        cmd := exec.CommandContext(ctx, "podman", "load")
        cmd.Stdin = tar

        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("podman load: %v: %s", err, strings.TrimSpace(string(out)))
                return fmt.Errorf("podman load: %w", err)
        }</span>

        <span class="cov1" title="1">log.Debugf("image loaded via podman CLI: %s", strings.TrimSpace(string(out)))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package patch

import (
        "errors"
        "io"
        "os"
        "strings"
        "time"

        "github.com/docker/buildx/build"
        "github.com/docker/cli/cli/config"
        "github.com/moby/buildkit/client"
        "github.com/moby/buildkit/session"
        "github.com/moby/buildkit/session/auth/authprovider"
        sourcepolicy "github.com/moby/buildkit/sourcepolicy/pb"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
)

// BuildConfig holds configuration for building and exporting images.
type BuildConfig struct {
        SolveOpt        client.SolveOpt
        ShouldExportOCI bool
        PipeWriter      io.WriteCloser
}

// createBuildConfig creates the build configuration for patching.
func createBuildConfig(
        patchedImageName string,
        shouldExportOCI bool,
        push bool,
        _ buildkit.Opts,
        pipeW io.WriteCloser,
) (*BuildConfig, error) <span class="cov8" title="1">{
        dockerConfig := config.LoadDefaultConfigFile(os.Stderr)
        cfg := authprovider.DockerAuthProviderConfig{ConfigFile: dockerConfig}
        attachable := []session.Attachable{authprovider.NewDockerAuthProvider(cfg)}

        // create solve options based on whether we're pushing to registry or loading to docker
        solveOpt := client.SolveOpt{
                Frontend: "",         // i.e. we are passing in the llb.Definition directly
                Session:  attachable, // used for authprovider, sshagentprovider and secretprovider
        }

        // determine which attributes to set for the export
        attrs := map[string]string{
                "name": patchedImageName,
                "annotation." + copaAnnotationKeyPrefix + ".image.patched": time.Now().UTC().Format(time.RFC3339),
        }
        if shouldExportOCI </span><span class="cov8" title="1">{
                attrs["oci-mediatypes"] = "true"
        }</span>

        <span class="cov8" title="1">if push </span><span class="cov8" title="1">{
                attrs["push"] = "true"
                solveOpt.Exports = []client.ExportEntry{
                        {
                                Type:  client.ExporterImage,
                                Attrs: attrs,
                        },
                }
        }</span> else<span class="cov0" title="0"> {
                solveOpt.Exports = []client.ExportEntry{
                        {
                                Type:  client.ExporterDocker,
                                Attrs: attrs,
                                Output: func(_ map[string]string) (io.WriteCloser, error) </span><span class="cov0" title="0">{
                                        return pipeW, nil
                                }</span>,
                        },
                }
        }

        // Set source policy
        <span class="cov8" title="1">sourcePolicy, err := build.ReadSourcePolicy()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">solveOpt.SourcePolicy = sourcePolicy

        if err := validateSourcePolicy(solveOpt.SourcePolicy); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;BuildConfig{
                SolveOpt:        solveOpt,
                ShouldExportOCI: shouldExportOCI,
                PipeWriter:      pipeW,
        }, nil</span>
}

// validateSourcePolicy validates that the source policy doesn't contain unsupported distributions.
func validateSourcePolicy(sourcePolicy *sourcepolicy.Policy) error <span class="cov8" title="1">{
        if sourcePolicy == nil || len(sourcePolicy.Rules) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">rule := sourcePolicy.Rules[0]
        identifier := rule.Updates.Identifier

        switch </span>{
        case strings.Contains(identifier, "redhat"):<span class="cov0" title="0">
                return errors.New("RedHat is not supported via source policies due to BusyBox not being in the RHEL repos\n" +
                        "Please use a different RPM-based image")</span>

        case strings.Contains(identifier, "rockylinux"):<span class="cov0" title="0">
                return errors.New("RockyLinux is not supported via source policies due to BusyBox not being in the RockyLinux repos\n" +
                        "Please use a different RPM-based image")</span>

        case strings.Contains(identifier, "alma"):<span class="cov0" title="0">
                return errors.New("AlmaLinux is not supported via source policies due to BusyBox not being in the AlmaLinux repos\n" +
                        "Please use a different RPM-based image")</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package patch

import (
        "context"
        "time"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/types"
        "github.com/spf13/cobra"

        // Register connection helpers for buildkit.
        _ "github.com/moby/buildkit/client/connhelper/dockercontainer"
        _ "github.com/moby/buildkit/client/connhelper/kubepod"
        _ "github.com/moby/buildkit/client/connhelper/nerdctlcontainer"
        _ "github.com/moby/buildkit/client/connhelper/podmancontainer"
        _ "github.com/moby/buildkit/client/connhelper/ssh"
        "github.com/moby/buildkit/util/progress/progressui"
)

type patchArgs struct {
        appImage      string
        report        string
        patchedTag    string
        suffix        string
        workingFolder string
        timeout       time.Duration
        scanner       string
        ignoreError   bool
        format        string
        output        string
        bkOpts        buildkit.Opts
        push          bool
        platform      []string
        loader        string
        progress      string
}

func NewPatchCmd() *cobra.Command <span class="cov8" title="1">{
        ua := patchArgs{}
        patchCmd := &amp;cobra.Command{
                Use:     "patch",
                Short:   "Patch container images with upgrade packages specified by a vulnerability report",
                Example: "copa patch -i images/python:3.7-alpine -r trivy.json -t 3.7-alpine-patched",
                RunE: func(_ *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        opts := &amp;types.Options{
                                Image:         ua.appImage,
                                Report:        ua.report,
                                PatchedTag:    ua.patchedTag,
                                Suffix:        ua.suffix,
                                WorkingFolder: ua.workingFolder,
                                Timeout:       ua.timeout,
                                Scanner:       ua.scanner,
                                IgnoreError:   ua.ignoreError,
                                Format:        ua.format,
                                Output:        ua.output,
                                BkAddr:        ua.bkOpts.Addr,
                                BkCACertPath:  ua.bkOpts.CACertPath,
                                BkCertPath:    ua.bkOpts.CertPath,
                                BkKeyPath:     ua.bkOpts.KeyPath,
                                Push:          ua.push,
                                Platforms:     ua.platform,
                                Progress:      progressui.DisplayMode(ua.progress),
                                Loader:        ua.loader,
                        }
                        return Patch(context.Background(), opts)
                }</span>,
        }
        <span class="cov8" title="1">flags := patchCmd.Flags()
        flags.StringVarP(&amp;ua.appImage, "image", "i", "", "Application image name and tag to patch")
        flags.StringVarP(&amp;ua.report, "report", "r", "", "Vulnerability report file or directory path")
        flags.StringVarP(&amp;ua.patchedTag, "tag", "t", "", "Tag for the patched image")
        flags.StringVarP(&amp;ua.suffix, "tag-suffix", "", "patched", "Suffix for the patched image (if no explicit --tag provided)")
        flags.StringVarP(&amp;ua.workingFolder, "working-folder", "w", "", "Working folder, defaults to system temp folder")
        flags.StringVarP(&amp;ua.bkOpts.Addr, "addr", "a", "", "Address of buildkitd service, defaults to local docker daemon with fallback to "+buildkit.DefaultAddr)
        flags.StringVarP(&amp;ua.bkOpts.CACertPath, "cacert", "", "", "Absolute path to buildkitd CA certificate")
        flags.StringVarP(&amp;ua.bkOpts.CertPath, "cert", "", "", "Absolute path to buildkit client certificate")
        flags.StringVarP(&amp;ua.bkOpts.KeyPath, "key", "", "", "Absolute path to buildkit client key")
        flags.DurationVar(&amp;ua.timeout, "timeout", 5*time.Minute, "Timeout for the operation, defaults to '5m'")
        flags.StringVarP(&amp;ua.scanner, "scanner", "s", "trivy", "Scanner used to generate the report, defaults to 'trivy'")
        flags.BoolVar(&amp;ua.ignoreError, "ignore-errors", false, "Ignore errors and continue patching (for single-platform: continue with other packages; for multi-platform: continue with other platforms)")
        flags.StringVarP(&amp;ua.format, "format", "f", "openvex", "Output format, defaults to 'openvex'")
        flags.StringVarP(&amp;ua.output, "output", "o", "", "Output file path")
        flags.BoolVarP(&amp;ua.push, "push", "p", false, "Push patched image to destination registry")
        flags.StringSliceVar(&amp;ua.platform, "platform", nil,
                "Target platform(s) for multi-arch images when no report directory is provided (e.g., linux/amd64,linux/arm64). "+
                        "Valid platforms: linux/amd64, linux/arm64, linux/riscv64, linux/ppc64le, linux/s390x, linux/386, linux/arm/v7, linux/arm/v6. "+
                        "If platform flag is used, only specified platforms are patched and the rest are preserved. If not specified, all platforms present in the image are patched.")
        flags.StringVarP(&amp;ua.loader, "loader", "l", "", "Loader to use for loading images. Options: 'docker', 'podman', or empty for auto-detection based on buildkit address")
        flags.StringVar(&amp;ua.progress, "progress", "auto", "Set the buildkit display mode (auto, plain, tty, quiet or rawjson). Set to quiet to discard all output.")

        if err := patchCmd.MarkFlagRequired("image"); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return patchCmd</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package patch

import (
        "context"
        "fmt"

        "github.com/moby/buildkit/client/llb"
        "github.com/moby/buildkit/exporter/containerimage/exptypes"
        gwclient "github.com/moby/buildkit/frontend/gateway/client"
        log "github.com/sirupsen/logrus"
        "golang.org/x/exp/slices"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/common"
        "github.com/project-copacetic/copacetic/pkg/pkgmgr"
        "github.com/project-copacetic/copacetic/pkg/types"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        "github.com/project-copacetic/copacetic/pkg/utils"
)

// Options contains the parameters needed for the core patching logic.
type Options struct {
        // Image and platform information
        ImageName      string
        TargetPlatform *types.PatchPlatform

        // Update information
        Updates *unversioned.UpdateManifest

        // Working environment
        WorkingFolder string
        IgnoreError   bool

        // Optional error channel for patch command integration
        ErrorChannel chan error
}

// Result contains the result of the core patching operation.
type Result struct {
        // BuildKit gateway result
        Result *gwclient.Result

        // Package manager information
        PackageType      string
        ErroredPackages  []string
        ValidatedUpdates []unversioned.UpdatePackage
}

// Context wraps the context and gateway client for core operations.
type Context struct {
        Context context.Context
        Client  gwclient.Client
}

// ExecutePatchCore executes the core patching logic that can be used by both
// the patch command and a buildkit frontend.
func ExecutePatchCore(patchCtx *Context, opts *Options) (*Result, error) <span class="cov0" title="0">{
        ctx := patchCtx.Context
        c := patchCtx.Client

        // Configure buildctl/client for use by package manager
        config, err := buildkit.InitializeBuildkitConfig(ctx, c, opts.ImageName, &amp;opts.TargetPlatform.Platform)
        if err != nil </span><span class="cov0" title="0">{
                if opts.ErrorChannel != nil </span><span class="cov0" title="0">{
                        opts.ErrorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Create package manager helper
        <span class="cov0" title="0">manager, err := setupPackageManager(ctx, c, config, opts)
        if err != nil </span><span class="cov0" title="0">{
                if opts.ErrorChannel != nil </span><span class="cov0" title="0">{
                        opts.ErrorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Apply patches and get the patched image state
        <span class="cov0" title="0">patchedImageState, errPkgs, err := manager.InstallUpdates(ctx, opts.Updates, opts.IgnoreError)
        if err != nil </span><span class="cov0" title="0">{
                if opts.ErrorChannel != nil </span><span class="cov0" title="0">{
                        opts.ErrorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Marshal the state for the target platform
        <span class="cov0" title="0">def, err := patchedImageState.Marshal(ctx, llb.Platform(opts.TargetPlatform.Platform))
        if err != nil </span><span class="cov0" title="0">{
                if opts.ErrorChannel != nil </span><span class="cov0" title="0">{
                        opts.ErrorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unable to get platform from ImageState %w", err)</span>
        }

        // Solve the definition to get the result
        <span class="cov0" title="0">res, err := c.Solve(ctx, gwclient.SolveRequest{
                Definition: def.ToPB(),
                Evaluate:   true,
        })
        if err != nil </span><span class="cov0" title="0">{
                if opts.ErrorChannel != nil </span><span class="cov0" title="0">{
                        opts.ErrorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Normalize the configuration for the target platform
        <span class="cov0" title="0">fixed, err := normalizeConfigForPlatform(config.ConfigData, opts.TargetPlatform)
        if err != nil </span><span class="cov0" title="0">{
                if opts.ErrorChannel != nil </span><span class="cov0" title="0">{
                        opts.ErrorChannel &lt;- err
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">res.AddMeta(exptypes.ExporterImageConfigKey, fixed)

        // Prepare the validated updates (excluding errored packages)
        var validatedUpdates []unversioned.UpdatePackage
        if opts.Updates != nil </span><span class="cov0" title="0">{
                for _, update := range opts.Updates.Updates </span><span class="cov0" title="0">{
                        if !slices.Contains(errPkgs, update.Name) </span><span class="cov0" title="0">{
                                validatedUpdates = append(validatedUpdates, update)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;Result{
                Result:           res,
                PackageType:      manager.GetPackageType(),
                ErroredPackages:  errPkgs,
                ValidatedUpdates: validatedUpdates,
        }, nil</span>
}

// setupPackageManager creates and configures the appropriate package manager
// based on the image's operating system.
func setupPackageManager(ctx context.Context, c gwclient.Client, config *buildkit.Config, opts *Options) (pkgmgr.PackageManager, error) <span class="cov0" title="0">{
        if opts.Updates == nil </span><span class="cov0" title="0">{
                // No vulnerability report provided - detect OS from image
                fileBytes, err := buildkit.ExtractFileFromState(ctx, c, &amp;config.ImageState, "/etc/os-release")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to extract /etc/os-release file from state %w", err)
                }</span>

                <span class="cov0" title="0">osInfo, err := common.GetOSInfo(ctx, fileBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">osType := osInfo.Type
                osVersion := osInfo.Version

                // Check for end-of-life status
                isEOL, eolDate, err := utils.CheckEOSL(osType, osVersion)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Failed to check EOL status for %s %s: %v. Patch attempt will proceed.", osType, osVersion, err)
                }</span> else<span class="cov0" title="0"> if isEOL </span><span class="cov0" title="0">{
                        eolMsg := fmt.Sprintf("The operating system %s %s appears to be End-Of-Support-Life.", osType, osVersion)
                        if eolDate != "Unknown" &amp;&amp; eolDate != "Not in EOL DB" &amp;&amp; eolDate != "Normalization Failed" &amp;&amp; eolDate != "API Rate Limited" </span><span class="cov0" title="0">{
                                eolMsg += fmt.Sprintf(" (EOL date: %s)", eolDate)
                        }</span>
                        <span class="cov0" title="0">eolMsg += " Patching may fail, be incomplete, or use archived repositories. Consider upgrading the base image."
                        log.Warn(eolMsg)</span>
                }

                // Get package manager based on detected OS
                <span class="cov0" title="0">return pkgmgr.GetPackageManager(osType, osVersion, config, opts.WorkingFolder)</span>
        }

        // Use OS information from the vulnerability report
        <span class="cov0" title="0">return pkgmgr.GetPackageManager(opts.Updates.Metadata.OS.Type, opts.Updates.Metadata.OS.Version, config, opts.WorkingFolder)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package patch

import (
        "net/url"

        log "github.com/sirupsen/logrus"

        "github.com/project-copacetic/copacetic/pkg/imageloader"
)

// detectLoaderFromBuildkitAddr attempts to determine the appropriate loader
// based on the buildkit connection address scheme.
func detectLoaderFromBuildkitAddr(addr string) string <span class="cov8" title="1">{
        if addr == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(addr)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("Failed to parse buildkit address %q: %v", addr, err)
                return ""
        }</span>

        <span class="cov0" title="0">switch u.Scheme </span>{
        case "podman-container":<span class="cov0" title="0">
                return imageloader.Podman</span>
        case "docker-container", "docker", "buildx":<span class="cov0" title="0">
                return imageloader.Docker</span>
        default:<span class="cov0" title="0">
                // Unknown scheme, let imageloader auto-detect
                return ""</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package patch

import (
        "context"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/distribution/reference"
        "github.com/docker/buildx/util/imagetools"
        "github.com/docker/cli/cli/config"
        "github.com/moby/buildkit/exporter/containerimage/exptypes"
        log "github.com/sirupsen/logrus"

        "github.com/project-copacetic/copacetic/pkg/types"
        "github.com/project-copacetic/copacetic/pkg/utils"
)

const (
        copaAnnotationKeyPrefix = "sh.copa"
)

// createMultiPlatformManifest assembles a multi-platform manifest list and pushes it
// via Buildx's imagetools helper (equivalent to
// `docker buildx imagetools create --tag … img@sha256:d1 img@sha256:d2 …`).
func createMultiPlatformManifest(
        ctx context.Context,
        imageName reference.NamedTagged,
        items []types.PatchResult,
        originalImage string,
) error <span class="cov0" title="0">{
        resolver := imagetools.New(imagetools.Opt{
                Auth: config.LoadDefaultConfigFile(os.Stderr),
        })

        // fetch annotations from the original image
        annotations := make(map[exptypes.AnnotationKey]string)

        // get the original image index manifest annotations
        originalAnnotations, err := utils.GetIndexManifestAnnotations(ctx, originalImage)
        if err != nil </span><span class="cov0" title="0">{
                log.Warnf("Failed to get original image annotations: %v", err)
                // continue without annotations rather than failing
        }</span> else<span class="cov0" title="0"> {
                log.Infof("Retrieved %d annotations from original image %s", len(originalAnnotations), originalImage)
                if len(originalAnnotations) &gt; 0 </span><span class="cov0" title="0">{
                        // copy all annotations from the original image
                        for k, v := range originalAnnotations </span><span class="cov0" title="0">{
                                // create an AnnotationKey for index level annotations
                                ak := exptypes.AnnotationKey{
                                        Type: exptypes.AnnotationIndex,
                                        Key:  k,
                                }
                                annotations[ak] = v
                        }</span>

                        // update annotations that should reflect the patched state
                        // update the created timestamp to reflect when the patch was applied
                        <span class="cov0" title="0">createdKey := exptypes.AnnotationKey{
                                Type: exptypes.AnnotationIndex,
                                Key:  "org.opencontainers.image.created",
                        }
                        annotations[createdKey] = time.Now().UTC().Format(time.RFC3339)

                        // if theres a version annotation, update it to reflect the patched tag
                        versionKey := exptypes.AnnotationKey{
                                Type: exptypes.AnnotationIndex,
                                Key:  "org.opencontainers.image.version",
                        }
                        if version, ok := annotations[versionKey]; ok </span><span class="cov0" title="0">{
                                // Extract the tag from the patched image name to determine what suffix to use
                                patchedTag := imageName.Tag()

                                // Try to determine what was added to the original version
                                // If the patched tag contains the original version, extract the suffix
                                if strings.Contains(patchedTag, version) </span><span class="cov0" title="0">{
                                        // Use the full patched tag as the new version
                                        annotations[versionKey] = patchedTag
                                }</span> else<span class="cov0" title="0"> {
                                        // Fallback: append the patched tag as a suffix
                                        annotations[versionKey] = version + "-" + patchedTag
                                }</span>
                        }

                        <span class="cov0" title="0">log.Debugf("Preserving %d annotations from original image", len(annotations))</span>
                } else<span class="cov0" title="0"> {
                        log.Info("No annotations found in original image, adding Copa annotations only")
                        // add Copa-specific annotations even if there are no original annotations
                        createdKey := exptypes.AnnotationKey{
                                Type: exptypes.AnnotationIndex,
                                Key:  "org.opencontainers.image.created",
                        }
                        annotations[createdKey] = time.Now().UTC().Format(time.RFC3339)
                }</span>
        }

        // add manifest descriptor level annotations for each platform
        <span class="cov0" title="0">for _, it := range items </span><span class="cov0" title="0">{
                if it.PatchedDesc != nil &amp;&amp; it.PatchedDesc.Platform != nil </span><span class="cov0" title="0">{
                        // use annotations that are already preserved in PatchedDesc.Annotations
                        // this works for both patched and pass-through platforms
                        if len(it.PatchedDesc.Annotations) &gt; 0 </span><span class="cov0" title="0">{
                                // add each annotation as a manifest-descriptor annotation
                                for k, v := range it.PatchedDesc.Annotations </span><span class="cov0" title="0">{
                                        ak := exptypes.AnnotationKey{
                                                Type:     exptypes.AnnotationManifestDescriptor,
                                                Platform: it.PatchedDesc.Platform,
                                                Key:      k,
                                        }
                                        // for patched platforms, update creation timestamp to reflect patching
                                        // for other platforms, preserve original timestamps
                                        if k == "org.opencontainers.image.created" &amp;&amp; it.PatchedRef != it.OriginalRef </span><span class="cov0" title="0">{
                                                // this is a patched platform, update the timestamp
                                                annotations[ak] = time.Now().UTC().Format(time.RFC3339)
                                        }</span> else<span class="cov0" title="0"> {
                                                // this is a platform with preserved or non-timestamp annotation
                                                annotations[ak] = v
                                        }</span>
                                }
                                <span class="cov0" title="0">log.Debugf("Added %d manifest-descriptor annotations for platform %s", len(it.PatchedDesc.Annotations), fmt.Sprintf("%s/%s", it.PatchedDesc.Platform.OS, it.PatchedDesc.Platform.Architecture))</span>
                        }
                }
        }

        // Source references (repo@sha256:digest) – one per architecture.
        <span class="cov0" title="0">srcRefs := make([]*imagetools.Source, 0, len(items))
        for _, it := range items </span><span class="cov0" title="0">{
                if it.PatchedDesc == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("patched descriptor is nil for %s", it.OriginalRef.String())
                }</span>

                <span class="cov0" title="0">srcRefs = append(srcRefs, &amp;imagetools.Source{
                        Ref:  it.PatchedRef,
                        Desc: *it.PatchedDesc,
                })</span>
        }

        <span class="cov0" title="0">idxBytes, desc, err := resolver.Combine(ctx, srcRefs, annotations, false)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to combine sources into manifest list: %w", err)
        }</span>

        <span class="cov0" title="0">err = resolver.Push(ctx, imageName, desc, idxBytes)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to push multi-platform manifest list: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package patch

import (
        "context"
        "errors"
        "fmt"
        "runtime"
        "strings"
        "sync"
        "text/tabwriter"

        "github.com/distribution/reference"
        log "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/common"
        "github.com/project-copacetic/copacetic/pkg/types"
)

// patchMultiPlatformImage patches a multi-platform image across all discovered platforms.
func patchMultiPlatformImage(
        ctx context.Context,
        ch chan error,
        opts *types.Options,
        discoveredPlatforms []types.PatchPlatform,
) error <span class="cov1" title="1">{
        image := opts.Image
        reportDir := opts.Report
        ignoreError := opts.IgnoreError
        log.Debugf("Handling platform specific errors with ignore-errors=%t", ignoreError)

        var platforms []types.PatchPlatform
        if reportDir != "" </span><span class="cov0" title="0">{
                // Using report directory - discover platforms from reports
                var err error
                platforms, err = buildkit.DiscoverPlatforms(image, reportDir, opts.Scanner)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if len(platforms) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no patchable platforms found for image %s", image)
                }</span>
        } else<span class="cov1" title="1"> {
                // No report directory - use discovered platforms and filter
                if len(discoveredPlatforms) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("no platforms provided for image %s", image)
                }</span>

                <span class="cov1" title="1">if len(opts.Platforms) &gt; 0 </span><span class="cov1" title="1">{
                        // Filter platforms based on user specification and validate
                        patchPlatforms := filterPlatforms(discoveredPlatforms, opts.Platforms)
                        if len(patchPlatforms) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("none of the specified platforms %v are available in the image", opts.Platforms)
                        }</span>

                        // Create a map to track which platforms should be patched
                        <span class="cov1" title="1">shouldPatchMap := make(map[string]bool)
                        for _, p := range patchPlatforms </span><span class="cov1" title="1">{
                                key := buildkit.PlatformKey(p.Platform)
                                shouldPatchMap[key] = true
                        }</span>

                        // Process all platforms, marking which should be patched vs preserved
                        <span class="cov1" title="1">for _, p := range discoveredPlatforms </span><span class="cov10" title="7">{
                                platformCopy := p
                                key := buildkit.PlatformKey(p.Platform)
                                if shouldPatchMap[key] </span><span class="cov1" title="1">{
                                        // Platform should be patched
                                        platformCopy.ReportFile = ""
                                        platformCopy.ShouldPreserve = false
                                }</span> else<span class="cov9" title="6"> {
                                        // Platform should be preserved
                                        platformCopy.ShouldPreserve = true
                                }</span>
                                <span class="cov10" title="7">platforms = append(platforms, platformCopy)</span>
                        }

                        <span class="cov1" title="1">log.Infof("Patching specified platforms, preserving others")</span>
                } else<span class="cov0" title="0"> {
                        // Patch all available platforms since no specific platforms were requested
                        for _, p := range discoveredPlatforms </span><span class="cov0" title="0">{
                                platformCopy := p
                                platformCopy.ReportFile = "" // No vulnerability report, just patch with latest packages
                                platformCopy.ShouldPreserve = false
                                platforms = append(platforms, platformCopy)
                        }</span>
                        <span class="cov0" title="0">log.Infof("Patching all available platforms")</span>
                }
        }

        <span class="cov1" title="1">sem := make(chan struct{}, runtime.NumCPU())
        g, gctx := errgroup.WithContext(ctx)

        var mu sync.Mutex
        patchResults := []types.PatchResult{}

        summaryMap := make(map[string]*types.MultiPlatformSummary)

        for _, p := range platforms </span><span class="cov10" title="7">{
                // rebind
                p := p //nolint
                platformKey := buildkit.PlatformKey(p.Platform)
                g.Go(func() error </span><span class="cov10" title="7">{
                        select </span>{
                        case sem &lt;- struct{}{}:<span class="cov10" title="7"></span>
                        case &lt;-gctx.Done():<span class="cov0" title="0">
                                return gctx.Err()</span>
                        }
                        <span class="cov10" title="7">defer func() </span><span class="cov10" title="7">{ &lt;-sem }</span>()

                        <span class="cov10" title="7">if p.ShouldPreserve </span><span class="cov9" title="6">{
                                // Platform marked for preservation - preserve original
                                log.Infof("Platform %s marked for preservation, preserving original in manifest", p.OS+"/"+p.Architecture)

                                // Parse the original image reference for the result
                                originalRef, err := reference.ParseNormalizedNamed(image)
                                if err != nil </span><span class="cov0" title="0">{
                                        mu.Lock()
                                        summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                                Platform: platformKey,
                                                Status:   "Error",
                                                Ref:      "",
                                                Message:  fmt.Sprintf("failed to parse original image reference: %v", err),
                                        }
                                        mu.Unlock()
                                        return err
                                }</span>

                                // Handle Windows platform without push enabled
                                <span class="cov9" title="6">if !opts.Push &amp;&amp; p.OS == "windows" </span><span class="cov0" title="0">{
                                        mu.Lock()
                                        defer mu.Unlock()
                                        if !ignoreError </span><span class="cov0" title="0">{
                                                summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                                        Platform: platformKey,
                                                        Status:   "Error",
                                                        Ref:      originalRef.String() + " (original reference)",
                                                        Message:  "Windows images are not patched",
                                                }
                                                return errors.New("cannot save Windows platform image without pushing to registry. Use --push flag to save Windows images to a registry or run with --ignore-errors")
                                        }</span>
                                        <span class="cov0" title="0">summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                                Platform: platformKey,
                                                Status:   "Ignored",
                                                Ref:      originalRef.String() + " (original reference)",
                                                Message:  "Windows images are not patched and will be preserved as-is",
                                        }
                                        log.Warn("Cannot save Windows platform image without pushing to registry. Use --push flag to save Windows images to a registry.")
                                        return nil</span>
                                }

                                // Get the original platform descriptor from the manifest
                                <span class="cov9" title="6">originalDesc, err := getPlatformDescriptorFromManifest(image, &amp;p)
                                if err != nil </span><span class="cov0" title="0">{
                                        mu.Lock()
                                        summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                                Platform: platformKey,
                                                Status:   "Error",
                                                Ref:      "",
                                                Message:  fmt.Sprintf("failed to get original descriptor for platform %s: %v", p.OS+"/"+p.Architecture, err),
                                        }
                                        mu.Unlock()
                                        return err
                                }</span>

                                // For platforms without reports, use the original image digest/reference
                                <span class="cov9" title="6">result := types.PatchResult{
                                        OriginalRef: originalRef,
                                        PatchedRef:  originalRef,
                                        PatchedDesc: originalDesc,
                                }

                                mu.Lock()
                                patchResults = append(patchResults, result)
                                // Add summary entry for unpatched platform
                                summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                        Platform: platformKey,
                                        Status:   "Not Patched",
                                        Ref:      originalRef.String() + " (original reference)",
                                        Message:  "Preserved original image (No Scan Report provided for platform)",
                                }
                                mu.Unlock()
                                return nil</span>
                        }

                        // When no report directory is provided, patch with empty report file
                        <span class="cov1" title="1">reportFile := p.ReportFile
                        if reportDir == "" </span><span class="cov1" title="1">{
                                reportFile = ""
                        }</span>

                        <span class="cov1" title="1">patchOpts := *opts
                        patchOpts.Report = reportFile
                        res, err := patchSingleArchImage(gctx, ch, &amp;patchOpts, p, true)
                        mu.Lock()
                        defer mu.Unlock()
                        if err != nil </span><span class="cov1" title="1">{
                                status := "Error"
                                if ignoreError </span><span class="cov0" title="0">{
                                        status = "Ignored"
                                }</span>
                                <span class="cov1" title="1">summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                        Platform: platformKey,
                                        Status:   status,
                                        Ref:      "",
                                        Message:  err.Error(),
                                }
                                if !ignoreError </span><span class="cov1" title="1">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        } else<span class="cov0" title="0"> if res == nil </span><span class="cov0" title="0">{
                                summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                        Platform: platformKey,
                                        Status:   "Error",
                                        Ref:      "",
                                        Message:  "patchSingleArchImage returned nil result",
                                }
                                return nil
                        }</span>

                        <span class="cov0" title="0">patchResults = append(patchResults, *res)
                        summaryMap[platformKey] = &amp;types.MultiPlatformSummary{
                                Platform: platformKey,
                                Status:   "Patched",
                                Ref:      res.PatchedRef.String(),
                                Message:  fmt.Sprintf("Successfully patched image (%s)", p.OS+"/"+p.Architecture),
                        }
                        return nil</span>
                })
        }

        <span class="cov1" title="1">if err := g.Wait(); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // resolve image ref
        <span class="cov0" title="0">imageName, err := reference.ParseNormalizedNamed(image)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse reference: %w", err)
        }</span>

        <span class="cov0" title="0">resolvedPatchedTag, err := common.ResolvePatchedTag(imageName, opts.PatchedTag, opts.Suffix)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">patchedImageName, err := reference.WithTag(imageName, resolvedPatchedTag)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse patched image name: %w", err)
        }</span>

        <span class="cov0" title="0">if opts.Push </span><span class="cov0" title="0">{
                err = createMultiPlatformManifest(ctx, patchedImageName, patchResults, image)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("manifest list creation failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if !opts.Push </span><span class="cov0" title="0">{
                // Show push commands only for actually patched images (not preserved originals)
                patchedOnlyResults := make([]types.PatchResult, 0)
                for _, result := range patchResults </span><span class="cov0" title="0">{
                        // Only include results where the patched ref differs from original ref
                        if result.PatchedRef.String() != result.OriginalRef.String() </span><span class="cov0" title="0">{
                                patchedOnlyResults = append(patchedOnlyResults, result)
                        }</span>
                }

                <span class="cov0" title="0">if len(patchedOnlyResults) &gt; 0 </span><span class="cov0" title="0">{
                        log.Info("To push the individual architecture images, run:")
                        for _, result := range patchedOnlyResults </span><span class="cov0" title="0">{
                                log.Infof("  docker push %s", result.PatchedRef.String())
                        }</span>
                        <span class="cov0" title="0">log.Infof("To create and push the multi-platform manifest, run:")

                        // Include all platforms (both patched and preserved) in the manifest create command
                        refs := make([]string, len(patchResults))
                        for i, result := range patchResults </span><span class="cov0" title="0">{
                                if result.PatchedRef.String() != result.OriginalRef.String() </span><span class="cov0" title="0">{
                                        // Use the patched reference for actually patched platforms
                                        refs[i] = result.PatchedRef.String()
                                }</span> else<span class="cov0" title="0"> {
                                        // Use the original reference with digest for preserved platforms
                                        if result.PatchedDesc != nil &amp;&amp; result.PatchedDesc.Digest.String() != "" </span><span class="cov0" title="0">{
                                                refs[i] = result.OriginalRef.String() + "@" + result.PatchedDesc.Digest.String()
                                        }</span> else<span class="cov0" title="0"> {
                                                refs[i] = result.OriginalRef.String()
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">log.Infof("  docker buildx imagetools create --tag %s %s", patchedImageName.String(), strings.Join(refs, " "))</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("no images were processed, check the logs for errors")
                }</span>
        }

        <span class="cov0" title="0">var b strings.Builder
        w := tabwriter.NewWriter(&amp;b, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "PLATFORM\tSTATUS\tREFERENCE\tMESSAGE")

        for _, p := range platforms </span><span class="cov0" title="0">{
                platformKey := buildkit.PlatformKey(p.Platform)
                s := summaryMap[platformKey]
                if s != nil </span><span class="cov0" title="0">{
                        ref := s.Ref
                        if ref == "" </span><span class="cov0" title="0">{
                                ref = "-"
                        }</span>
                        <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\t%s\n", s.Platform, s.Status, ref, s.Message)</span>
                }
        }
        <span class="cov0" title="0">w.Flush()
        log.Info("\nMulti-arch patch summary:\n" + b.String())

        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package patch

import (
        "context"
        "fmt"
        "os"
        "time"

        "github.com/moby/buildkit/util/progress/progressui"
        log "github.com/sirupsen/logrus"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/common"
        "github.com/project-copacetic/copacetic/pkg/types"
)

// for testing.
var (
        bkNewClient = buildkit.NewClient
)

// Patch executes the patching workflow for a given set of options.
func Patch(ctx context.Context, opts *types.Options) error <span class="cov8" title="1">{
        allowedProgressModes := map[string]struct{}{
                "auto":    {},
                "plain":   {},
                "tty":     {},
                "quiet":   {},
                "rawjson": {},
        }
        if _, ok := allowedProgressModes[string(opts.Progress)]; !ok </span><span class="cov0" title="0">{
                log.Warnf("Invalid value for --progress: %q. Allowed values are 'auto', 'plain' 'tty', 'quiet' or 'rawjson'. Defaulting to 'auto'.", string(opts.Progress))
                opts.Progress = progressui.DisplayMode("auto")
        }</span>
        // Create timeout context
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, opts.Timeout)
        defer cancel()

        ch := make(chan error)
        defer close(ch)

        go func() </span><span class="cov8" title="1">{
                ch &lt;- patchWithContext(timeoutCtx, ch, opts)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-ch:<span class="cov8" title="1">
                return err</span>
        case &lt;-timeoutCtx.Done():<span class="cov0" title="0">
                // add a grace period for long running deferred cleanup functions to complete
                &lt;-time.After(1 * time.Second)

                err := fmt.Errorf("patch exceeded timeout %v", opts.Timeout)
                log.Error(err)
                return err</span>
        }
}

// patchWithContext orchestrates the main patching workflow.
func patchWithContext(ctx context.Context, ch chan error, opts *types.Options) error <span class="cov8" title="1">{
        image := opts.Image
        reportPath := opts.Report
        targetPlatforms := opts.Platforms

        // Validate configuration based on source policy if present
        if err := validateBuildConfiguration(opts); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build configuration validation failed: %w", err)
        }</span>

        // Handle empty report path - check if image is manifest list or single platform
        <span class="cov8" title="1">if reportPath == "" </span><span class="cov8" title="1">{
                // Discover platforms from the image reference to determine if it's multi-platform
                discoveredPlatforms, err := buildkit.DiscoverPlatformsFromReference(image)
                if err != nil </span><span class="cov0" title="0">{
                        // Failed to discover platforms - treat as single-platform image
                        log.Warnf("Failed to discover platforms for image %s (treating as single-platform): %v", image, err)
                        if len(targetPlatforms) &gt; 0 </span><span class="cov0" title="0">{
                                log.Info("Platform flag ignored when platform discovery fails")
                        }</span>

                        // Fallback to default platform
                        <span class="cov0" title="0">defaultPlatform := common.GetDefaultLinuxPlatform()
                        patchPlatform := types.PatchPlatform{
                                Platform:       defaultPlatform,
                                ReportFile:     "",
                                ShouldPreserve: false,
                        }

                        result, err := patchSingleArchImage(ctx, ch, opts, patchPlatform, false)
                        if err == nil &amp;&amp; result != nil &amp;&amp; result.PatchedRef != nil </span><span class="cov0" title="0">{
                                log.Infof("Patched image (%s): %s\n", patchPlatform.OS+"/"+patchPlatform.Architecture, result.PatchedRef)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">if len(discoveredPlatforms) &lt;= 1 </span><span class="cov0" title="0">{
                        // Single-platform image or multi-platform with only one valid platform
                        log.Debugf("Detected single-platform image or multi-platform with single valid platform")
                        if len(targetPlatforms) &gt; 0 </span><span class="cov0" title="0">{
                                log.Info("Platform flag ignored for single-platform image")
                        }</span>

                        <span class="cov0" title="0">var patchPlatform types.PatchPlatform
                        if len(discoveredPlatforms) == 1 </span><span class="cov0" title="0">{
                                // Use the discovered platform from the manifest
                                patchPlatform = discoveredPlatforms[0]
                                log.Debugf("Using discovered platform from manifest: %s/%s", patchPlatform.OS, patchPlatform.Architecture)
                        }</span> else<span class="cov0" title="0"> {
                                // No platforms discovered, use default
                                defaultPlatform := common.GetDefaultLinuxPlatform()
                                patchPlatform = types.PatchPlatform{
                                        Platform:       defaultPlatform,
                                        ReportFile:     "",
                                        ShouldPreserve: false,
                                }
                        }</span>

                        <span class="cov0" title="0">result, err := patchSingleArchImage(ctx, ch, opts, patchPlatform, false)
                        if err == nil &amp;&amp; result != nil &amp;&amp; result.PatchedRef != nil </span><span class="cov0" title="0">{
                                log.Infof("Patched image (%s): %s\n", patchPlatform.OS+"/"+patchPlatform.Architecture, result.PatchedRef)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">log.Debugf("Detected multi-platform image with %d platforms", len(discoveredPlatforms))
                return patchMultiPlatformImage(ctx, ch, opts, discoveredPlatforms)</span>
        }

        // Check if reportPath exists
        <span class="cov0" title="0">if _, err := os.Stat(reportPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("report path %s does not exist", reportPath)
        }</span>

        // Get file info to determine if it's a file or directory
        <span class="cov0" title="0">f, err := os.Stat(reportPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stat report path %s: %w", reportPath, err)
        }</span>

        <span class="cov0" title="0">if f.IsDir() </span><span class="cov0" title="0">{
                // Handle directory - multi-platform patching
                log.Debugf("Using report directory: %s", reportPath)
                if len(targetPlatforms) &gt; 0 </span><span class="cov0" title="0">{
                        log.Info("Platform flag ignored when report directory is provided")
                }</span>
                // For report directory, we pass nil as discoveredPlatforms - the function will discover them internally
                <span class="cov0" title="0">return patchMultiPlatformImage(ctx, ch, opts, nil)</span>
        }
        // Handle file - single-platform patching
        <span class="cov0" title="0">log.Debugf("Using report file: %s", reportPath)
        defaultPlatform := common.GetDefaultLinuxPlatform()
        patchPlatform := types.PatchPlatform{
                Platform: defaultPlatform,
        }
        result, err := patchSingleArchImage(ctx, ch, opts, patchPlatform, false)
        if err == nil &amp;&amp; result != nil </span><span class="cov0" title="0">{
                log.Infof("Patched image (%s): %s\n", patchPlatform.OS+"/"+patchPlatform.Architecture, result.PatchedRef.String())
        }</span>
        <span class="cov0" title="0">return err</span>
}

// validateBuildConfiguration validates the build configuration and source policies.
func validateBuildConfiguration(opts *types.Options) error <span class="cov8" title="1">{
        // Validate source policy if build options are provided
        if opts.BkAddr != "" </span><span class="cov0" title="0">{
                bkOpts := buildkit.Opts{
                        Addr:       opts.BkAddr,
                        CACertPath: opts.BkCACertPath,
                        CertPath:   opts.BkCertPath,
                        KeyPath:    opts.BkKeyPath,
                }

                // Create temporary build config to validate source policy
                _, err := createBuildConfig("temp", false, false, bkOpts, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create build configuration: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package patch

import (
        "encoding/json"
        "fmt"

        "github.com/containerd/platforms"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/opencontainers/go-digest"
        ispec "github.com/opencontainers/image-spec/specs-go/v1"
        log "github.com/sirupsen/logrus"
        "golang.org/x/exp/slices"

        "github.com/project-copacetic/copacetic/pkg/types"
)

const (
        ARM64 = "arm64"
)

var validPlatforms = []string{
        "linux/386",
        "linux/amd64",
        "linux/arm",
        "linux/arm/v5",
        "linux/arm/v6",
        "linux/arm/v7",
        "linux/arm64",
        "linux/arm64/v8",
        "linux/ppc64le",
        "linux/s390x",
        "linux/riscv64",
}

// archTag returns "patched-arm64" or "patched-arm-v7" etc.
func archTag(base, arch, variant string) string <span class="cov4" title="4">{
        if variant != "" </span><span class="cov2" title="2">{
                return fmt.Sprintf("%s-%s-%s", base, arch, variant)
        }</span>
        <span class="cov2" title="2">return fmt.Sprintf("%s-%s", base, arch)</span>
}

// normalizeConfigForPlatform adjusts the image configuration for a specific platform.
func normalizeConfigForPlatform(j []byte, p *types.PatchPlatform) ([]byte, error) <span class="cov2" title="2">{
        if p == nil </span><span class="cov0" title="0">{
                return j, fmt.Errorf("platform is nil")
        }</span>

        <span class="cov2" title="2">var m map[string]any
        if err := json.Unmarshal(j, &amp;m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov2" title="2">m["architecture"] = p.Architecture
        if p.Variant != "" </span><span class="cov1" title="1">{
                m["variant"] = p.Variant
        }</span> else<span class="cov1" title="1"> {
                delete(m, "variant")
        }</span>
        <span class="cov2" title="2">m["os"] = p.OS

        return json.Marshal(m)</span>
}

// filterPlatforms filters discovered platforms based on user-specified target platforms.
func filterPlatforms(discoveredPlatforms []types.PatchPlatform, targetPlatforms []string) []types.PatchPlatform <span class="cov1" title="1">{
        var filtered []types.PatchPlatform

        for _, target := range targetPlatforms </span><span class="cov1" title="1">{
                // Validate platform against allowed list
                if !slices.Contains(validPlatforms, target) </span><span class="cov0" title="0">{
                        log.Warnf("Platform %s is not in the list of valid platforms: %v", target, validPlatforms)
                        continue</span>
                }

                <span class="cov1" title="1">targetPlatform, err := platforms.Parse(target)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Invalid platform format %s: %v", target, err)
                        continue</span>
                }
                <span class="cov1" title="1">targetPlatform = platforms.Normalize(targetPlatform)

                for _, discovered := range discoveredPlatforms </span><span class="cov1" title="1">{
                        if platforms.Only(targetPlatform).Match(discovered.Platform) </span><span class="cov1" title="1">{
                                filtered = append(filtered, discovered)
                                break</span>
                        }
                }
        }

        <span class="cov1" title="1">return filtered</span>
}

// getPlatformDescriptorFromManifest gets the descriptor for a specific platform from a multi-arch manifest.
func getPlatformDescriptorFromManifest(
        imageRef string,
        targetPlatform *types.PatchPlatform,
) (*ispec.Descriptor, error) <span class="cov5" title="6">{
        ref, err := name.ParseReference(imageRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing reference %q: %w", imageRef, err)
        }</span>

        <span class="cov5" title="6">desc, err := remote.Get(ref)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error fetching descriptor for %q: %w", imageRef, err)
        }</span>

        <span class="cov5" title="6">if !desc.MediaType.IsIndex() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected multi-platform image but got single-platform image")
        }</span>

        <span class="cov5" title="6">index, err := desc.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting image index: %w", err)
        }</span>

        <span class="cov5" title="6">manifest, err := index.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting manifest: %w", err)
        }</span>

        // Find the descriptor for the target platform
        <span class="cov5" title="6">for i := range manifest.Manifests </span><span class="cov10" title="48">{
                m := &amp;manifest.Manifests[i]
                if m.Platform == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Normalize the variant comparison - treat missing variant as empty string
                <span class="cov10" title="48">manifestVariant := m.Platform.Variant
                targetVariant := targetPlatform.Variant
                if m.Platform.Architecture == ARM64 &amp;&amp; manifestVariant == "v8" </span><span class="cov4" title="4">{
                        manifestVariant = ""
                }</span>
                <span class="cov10" title="48">if targetPlatform.Architecture == ARM64 &amp;&amp; targetVariant == "v8" </span><span class="cov0" title="0">{
                        targetVariant = ""
                }</span>

                <span class="cov10" title="48">if m.Platform.OS == targetPlatform.OS &amp;&amp;
                        m.Platform.Architecture == targetPlatform.Architecture &amp;&amp;
                        manifestVariant == targetVariant &amp;&amp;
                        m.Platform.OSVersion == targetPlatform.OSVersion </span><span class="cov5" title="6">{
                        // Convert the descriptor to the expected format
                        ociDesc := &amp;ispec.Descriptor{
                                MediaType: string(m.MediaType),
                                Size:      m.Size,
                                Digest:    digest.Digest(m.Digest.String()),
                                Platform: &amp;ispec.Platform{
                                        OS:           m.Platform.OS,
                                        Architecture: m.Platform.Architecture,
                                        Variant:      m.Platform.Variant,
                                        OSVersion:    m.Platform.OSVersion,
                                        OSFeatures:   m.Platform.OSFeatures,
                                },
                                Annotations: m.Annotations,
                        }
                        return ociDesc, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("platform %s/%s not found in manifest", targetPlatform.OS, targetPlatform.Architecture)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package patch

import (
        "context"
        "fmt"
        "io"
        "maps"
        "os"
        "strings"
        "time"

        "github.com/containerd/platforms"
        "github.com/distribution/reference"
        "github.com/moby/buildkit/client"
        "github.com/moby/buildkit/exporter/containerimage/exptypes"
        gwclient "github.com/moby/buildkit/frontend/gateway/client"
        ispec "github.com/opencontainers/image-spec/specs-go/v1"
        log "github.com/sirupsen/logrus"
        "golang.org/x/sync/errgroup"

        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/common"
        "github.com/project-copacetic/copacetic/pkg/imageloader"
        "github.com/project-copacetic/copacetic/pkg/report"
        "github.com/project-copacetic/copacetic/pkg/types"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        "github.com/project-copacetic/copacetic/pkg/utils"
        "github.com/project-copacetic/copacetic/pkg/vex"
)

const (
        copaProduct = "copa"
        defaultTag  = "latest"
        LINUX       = "linux"
)

// getRepoNameWithDigest extracts repo name with digest from image name and digest.
// e.g. "docker.io/library/nginx:1.21.6-patched" -&gt; "nginx@sha256:...".
func getRepoNameWithDigest(patchedImageName, imageDigest string) string <span class="cov9" title="5">{
        parts := strings.Split(patchedImageName, "/")
        last := parts[len(parts)-1]
        if idx := strings.IndexRune(last, ':'); idx &gt;= 0 </span><span class="cov6" title="3">{
                last = last[:idx]
        }</span>
        <span class="cov9" title="5">nameWithDigest := fmt.Sprintf("%s@%s", last, imageDigest)
        return nameWithDigest</span>
}

// removeIfNotDebug removes working folder unless debug mode is enabled.
func removeIfNotDebug(workingFolder string) <span class="cov10" title="6">{
        if log.GetLevel() &gt;= log.DebugLevel </span><span class="cov4" title="2">{
                // Keep the intermediate outputs for outputs solved to working folder if debugging
                log.Warnf("--debug specified, working folder at %s needs to be manually cleaned up", workingFolder)
        }</span> else<span class="cov7" title="4"> {
                os.RemoveAll(workingFolder)
        }</span>
}

// patchSingleArchImage patches a single architecture image.
func patchSingleArchImage(
        ctx context.Context,
        ch chan error,
        opts *types.Options,
        //nolint:gocritic
        targetPlatform types.PatchPlatform,
        multiPlatform bool,
) (*types.PatchResult, error) <span class="cov1" title="1">{
        // Extract options
        image := opts.Image
        reportFile := opts.Report
        patchedTag := opts.PatchedTag
        suffix := opts.Suffix
        workingFolder := opts.WorkingFolder
        scanner := opts.Scanner
        format := opts.Format
        output := opts.Output
        loader := opts.Loader
        ignoreError := opts.IgnoreError
        push := opts.Push
        bkOpts := buildkit.Opts{
                Addr:       opts.BkAddr,
                CACertPath: opts.BkCACertPath,
                CertPath:   opts.BkCertPath,
                KeyPath:    opts.BkKeyPath,
        }

        if reportFile == "" &amp;&amp; output != "" </span><span class="cov0" title="0">{
                log.Warn("No vulnerability report was provided, so no VEX output will be generated.")
        }</span>

        // if the target platform is different from the host platform, we need to check if emulation is enabled
        // only need to do this check if we're patching a multi-platform image
        <span class="cov1" title="1">if multiPlatform </span><span class="cov1" title="1">{
                if err := validatePlatformEmulation(targetPlatform); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // parse the image reference
        <span class="cov1" title="1">imageName, err := reference.ParseNormalizedNamed(image)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse reference: %w", err)
        }</span>

        // resolve final patched tag
        <span class="cov1" title="1">patchedTag, err = common.ResolvePatchedTag(imageName, patchedTag, suffix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">if multiPlatform </span><span class="cov1" title="1">{
                patchedTag = archTag(patchedTag, targetPlatform.Architecture, targetPlatform.Variant)
        }</span>
        <span class="cov1" title="1">patchedImageName := fmt.Sprintf("%s:%s", imageName.Name(), patchedTag)
        log.Infof("Patched image name: %s", patchedImageName)

        // Setup working folder
        workingFolder, cleanup, err := setupWorkingFolder(workingFolder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer cleanup()

        // Parse report for update packages
        var updates *unversioned.UpdateManifest
        if reportFile != "" </span><span class="cov0" title="0">{
                updates, err = report.TryParseScanReport(reportFile, scanner)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Debugf("updates to apply: %v", updates)</span>
        }

        // Create buildkit client
        <span class="cov1" title="1">bkClient, err := bkNewClient(ctx, bkOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer bkClient.Close()

        // Resolve image reference
        ref := resolveImageReference(imageName)

        // Determine the loader type
        finalLoaderType := determineLoaderType(loader, bkOpts.Addr)

        // Check media type for OCI vs Docker export
        shouldExportOCI := shouldExportAsOCI(ref, finalLoaderType)

        // Create pipes for Docker export
        pipeR, pipeW := io.Pipe()

        // Create build configuration
        buildConfig, err := createBuildConfig(patchedImageName, shouldExportOCI, push, bkOpts, pipeW)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create channels for build coordination
        <span class="cov1" title="1">buildChannel := make(chan *client.SolveStatus)
        eg, ctx := errgroup.WithContext(ctx)

        // Start the main build process
        eg.Go(func() error </span><span class="cov1" title="1">{
                return executePatchBuild(ctx, ch, bkClient, buildConfig, imageName, &amp;targetPlatform,
                        workingFolder, updates, ignoreError, reportFile, scanner, format, output, patchedImageName, buildChannel)
        }</span>)

        // Display progress
        <span class="cov1" title="1">common.DisplayProgress(ctx, eg, buildChannel, opts.Progress)

        // Handle image loading if not pushing
        if !push </span><span class="cov0" title="0">{
                eg.Go(func() error </span><span class="cov0" title="0">{
                        return loadImageToRuntime(ctx, pipeR, patchedImageName, finalLoaderType)
                }</span>)
        } else<span class="cov1" title="1"> {
                go func() </span><span class="cov1" title="1">{
                        pipeR.Close()
                }</span>()
        }

        // Wait for completion
        <span class="cov1" title="1">if err := eg.Wait(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Get patched descriptor and add annotations
        <span class="cov0" title="0">return createPatchResult(ctx, imageName, patchedImageName, &amp;targetPlatform, image, finalLoaderType)</span>
}

// validatePlatformEmulation checks if emulation is available for cross-platform builds.
func validatePlatformEmulation(targetPlatform types.PatchPlatform) error <span class="cov1" title="1">{ //nolint:gocritic
        hostPlatform := platforms.Normalize(platforms.DefaultSpec())
        if hostPlatform.OS != LINUX </span><span class="cov0" title="0">{
                hostPlatform.OS = LINUX
        }</span>

        <span class="cov1" title="1">platformsEqual := hostPlatform.OS == targetPlatform.OS &amp;&amp;
                hostPlatform.Architecture == targetPlatform.Architecture

        if platformsEqual </span><span class="cov1" title="1">{
                log.Debugf("Host platform %+v matches target platform %+v", hostPlatform, targetPlatform)
                return nil
        }</span>

        <span class="cov0" title="0">log.Debugf("Host platform %+v does not match target platform %+v", hostPlatform, targetPlatform)

        if emulationEnabled := buildkit.QemuAvailable(&amp;targetPlatform); !emulationEnabled </span><span class="cov0" title="0">{
                return fmt.Errorf("emulation is not enabled for platform %s", targetPlatform.OS+"/"+targetPlatform.Architecture)
        }</span>

        <span class="cov0" title="0">log.Debugf("Emulation is enabled for platform %+v", targetPlatform)
        return nil</span>
}

// setupWorkingFolder creates and configures the working directory.
func setupWorkingFolder(workingFolder string) (string, func(), error) <span class="cov1" title="1">{
        if workingFolder == "" </span><span class="cov1" title="1">{
                var err error
                workingFolder, err = os.MkdirTemp("", "copa-*")
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil, err
                }</span>
                <span class="cov1" title="1">cleanup := func() </span><span class="cov1" title="1">{ removeIfNotDebug(workingFolder) }</span>
                <span class="cov1" title="1">if err = os.Chmod(workingFolder, 0o744); err != nil </span><span class="cov0" title="0">{
                        cleanup()
                        return "", nil, err
                }</span>
                <span class="cov1" title="1">return workingFolder, cleanup, nil</span>
        }

        <span class="cov0" title="0">isNew, err := utils.EnsurePath(workingFolder, 0o744)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to create workingFolder %s", workingFolder)
                return "", nil, err
        }</span>

        <span class="cov0" title="0">cleanup := func() </span>{<span class="cov0" title="0">}</span>
        <span class="cov0" title="0">if isNew </span><span class="cov0" title="0">{
                cleanup = func() </span><span class="cov0" title="0">{ removeIfNotDebug(workingFolder) }</span>
        }

        <span class="cov0" title="0">return workingFolder, cleanup, nil</span>
}

// resolveImageReference resolves the final image reference string.
func resolveImageReference(imageName reference.Named) string <span class="cov1" title="1">{
        if reference.IsNameOnly(imageName) </span><span class="cov0" title="0">{
                log.Warnf("Image name has no tag or digest, using latest as tag")
                return fmt.Sprintf("%s:%s", imageName.Name(), defaultTag)
        }</span>
        <span class="cov1" title="1">log.Debugf("Image name has tag or digest, using %s as tag", imageName.String())
        return imageName.String()</span>
}

// determineLoaderType determines the appropriate image loader.
func determineLoaderType(loader, bkAddr string) string <span class="cov1" title="1">{
        finalLoaderType := loader
        if finalLoaderType == "" </span><span class="cov1" title="1">{
                finalLoaderType = detectLoaderFromBuildkitAddr(bkAddr)
                if finalLoaderType != "" </span><span class="cov0" title="0">{
                        log.Debugf("Auto-detected loader type %q from buildkit address %q", finalLoaderType, bkAddr)
                }</span>
        }
        <span class="cov1" title="1">return finalLoaderType</span>
}

// shouldExportAsOCI determines if the image should be exported as OCI format.
func shouldExportAsOCI(ref, loaderType string) bool <span class="cov1" title="1">{
        mt, err := utils.GetMediaType(ref, loaderType)
        shouldExportOCI := err == nil &amp;&amp; strings.Contains(mt, "vnd.oci.image")

        switch </span>{
        case shouldExportOCI:<span class="cov1" title="1">
                log.Debug("resolved media type is OCI")</span>
        case err != nil:<span class="cov0" title="0">
                log.Warnf("unable to determine media type, defaulting to docker, err: %v", err)</span>
        default:<span class="cov0" title="0">
                log.Warnf("resolved media type is Docker")</span>
        }

        <span class="cov1" title="1">return shouldExportOCI</span>
}

// loadImageToRuntime loads the built image into the container runtime.
func loadImageToRuntime(ctx context.Context, pipeR io.ReadCloser, patchedImageName, loaderType string) error <span class="cov0" title="0">{
        imgLoader, err := imageloader.New(ctx, imageloader.Config{Loader: loaderType})
        if err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to create loader: %w", err)
                if pipeReader, ok := pipeR.(*io.PipeReader); ok </span><span class="cov0" title="0">{
                        pipeReader.CloseWithError(err)
                }</span> else<span class="cov0" title="0"> {
                        pipeR.Close()
                }</span>
                <span class="cov0" title="0">log.Error(err)
                return err</span>
        }

        <span class="cov0" title="0">if err := imgLoader.Load(ctx, pipeR, patchedImageName); err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to load image: %w", err)
                if pipeReader, ok := pipeR.(*io.PipeReader); ok </span><span class="cov0" title="0">{
                        pipeReader.CloseWithError(err)
                }</span> else<span class="cov0" title="0"> {
                        pipeR.Close()
                }</span>
                <span class="cov0" title="0">log.Error(err)
                return err</span>
        }
        <span class="cov0" title="0">return pipeR.Close()</span>
}

// createPatchResult creates the final patch result with descriptor and annotations.
func createPatchResult(ctx context.Context, imageName reference.Named, patchedImageName string,
        targetPlatform *types.PatchPlatform, image, loaderType string,
) (*types.PatchResult, error) <span class="cov0" title="0">{
        // Use the appropriate runtime for image descriptor lookup
        runtime := imageloader.Docker
        if loaderType == imageloader.Podman </span><span class="cov0" title="0">{
                runtime = imageloader.Podman
        }</span>

        <span class="cov0" title="0">patchedDesc, err := utils.GetImageDescriptor(ctx, patchedImageName, runtime)
        if err != nil </span><span class="cov0" title="0">{
                prettyPlatform := platforms.Format(targetPlatform.Platform)
                log.Warnf("failed to get patched image descriptor for platform '%s': %v", prettyPlatform, err)
        }</span>

        // Add original manifest annotations if we have a patched descriptor
        <span class="cov0" title="0">if patchedDesc != nil </span><span class="cov0" title="0">{
                originalAnnotations, err := utils.GetPlatformManifestAnnotations(ctx, image, &amp;ispec.Platform{
                        OS:           targetPlatform.OS,
                        Architecture: targetPlatform.Architecture,
                        Variant:      targetPlatform.Variant,
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Warnf("Failed to get original manifest level annotations for platform %s: %v", targetPlatform.Platform, err)
                }</span> else<span class="cov0" title="0"> if len(originalAnnotations) &gt; 0 </span><span class="cov0" title="0">{
                        // Create augmented descriptor with original annotations
                        augmentedDesc := *patchedDesc
                        if augmentedDesc.Annotations == nil </span><span class="cov0" title="0">{
                                augmentedDesc.Annotations = make(map[string]string)
                        }</span>

                        // Copy original annotations
                        <span class="cov0" title="0">maps.Copy(augmentedDesc.Annotations, originalAnnotations)

                        // Update creation timestamp and add Copa annotations
                        augmentedDesc.Annotations["org.opencontainers.image.created"] = time.Now().UTC().Format(time.RFC3339)
                        augmentedDesc.Annotations[copaAnnotationKeyPrefix+".image.patched"] = time.Now().UTC().Format(time.RFC3339)

                        patchedDesc = &amp;augmentedDesc
                        log.Debugf("Preserved %d manifest level annotations for platform %s", len(originalAnnotations), targetPlatform.Platform)</span>
                }
        }

        <span class="cov0" title="0">patchedRef, err := reference.ParseNamed(patchedImageName)
        log.Debugf("Patched image name: %s", patchedImageName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse patched image name %s: %w", patchedImageName, err)
        }</span>

        <span class="cov0" title="0">return &amp;types.PatchResult{
                OriginalRef: imageName,
                PatchedRef:  patchedRef,
                PatchedDesc: patchedDesc,
        }, nil</span>
}

// executePatchBuild executes the actual patch build process.
func executePatchBuild(
        ctx context.Context,
        ch chan error,
        bkClient *client.Client,
        buildConfig *BuildConfig,
        imageName reference.Named,
        targetPlatform *types.PatchPlatform,
        workingFolder string,
        updates *unversioned.UpdateManifest,
        ignoreError bool,
        reportFile, _, format, output, patchedImageName string,
        buildChannel chan *client.SolveStatus,
) error <span class="cov1" title="1">{
        var pkgType string
        var validatedManifest *unversioned.UpdateManifest
        if updates != nil </span><span class="cov0" title="0">{
                // create a new manifest with the successfully patched packages
                validatedManifest = &amp;unversioned.UpdateManifest{
                        Metadata: unversioned.Metadata{
                                OS: unversioned.OS{
                                        Type:    updates.Metadata.OS.Type,
                                        Version: updates.Metadata.OS.Version,
                                },
                                Config: unversioned.Config{
                                        Arch: updates.Metadata.Config.Arch,
                                },
                        },
                        Updates: []unversioned.UpdatePackage{},
                }
        }</span>

        <span class="cov1" title="1">solveResponse, err := bkClient.Build(ctx, buildConfig.SolveOpt, copaProduct, func(ctx context.Context, c gwclient.Client) (*gwclient.Result, error) </span><span class="cov0" title="0">{
                // Create patch context and options
                patchCtx := &amp;Context{
                        Context: ctx,
                        Client:  c,
                }

                patchOpts := &amp;Options{
                        ImageName:      imageName.String(),
                        TargetPlatform: targetPlatform,
                        Updates:        updates,
                        WorkingFolder:  workingFolder,
                        IgnoreError:    ignoreError,
                        ErrorChannel:   ch,
                }

                // Execute the core patching logic
                result, err := ExecutePatchCore(patchCtx, patchOpts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Update validation data for VEX document generation
                <span class="cov0" title="0">pkgType = result.PackageType
                if validatedManifest != nil </span><span class="cov0" title="0">{
                        validatedManifest.Updates = result.ValidatedUpdates
                }</span>

                <span class="cov0" title="0">return result.Result, nil</span>
        }, buildChannel)

        // Currently can only validate updates if updating via scanner
        <span class="cov1" title="1">var patchedImageDigest string
        if err == nil &amp;&amp; solveResponse != nil </span><span class="cov0" title="0">{
                digest := solveResponse.ExporterResponse[exptypes.ExporterImageDigestKey]
                patchedImageDigest = digest
        }</span>
        <span class="cov1" title="1">if patchedImageDigest != "" &amp;&amp; reportFile != "" &amp;&amp; validatedManifest != nil </span><span class="cov0" title="0">{
                nameDigestOrTag := getRepoNameWithDigest(patchedImageName, patchedImageDigest)
                // vex document must contain at least one statement
                if output != "" &amp;&amp; len(validatedManifest.Updates) &gt; 0 </span><span class="cov0" title="0">{
                        if err := vex.TryOutputVexDocument(validatedManifest, pkgType, nameDigestOrTag, format, output); err != nil </span><span class="cov0" title="0">{
                                ch &lt;- err
                                return err
                        }</span>
                }
        }

        <span class="cov1" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package pkgmgr

import (
        "bufio"
        "bytes"
        "context"
        "fmt"
        "sort"
        "strings"

        "github.com/hashicorp/go-multierror"
        apkVer "github.com/knqyf263/go-apk-version"
        "github.com/moby/buildkit/client/llb"
        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        "github.com/project-copacetic/copacetic/pkg/utils"
        log "github.com/sirupsen/logrus"
)

type apkManager struct {
        config        *buildkit.Config
        workingFolder string
}

// Depending on go-apk-version lib for APK version comparison rules.
func isValidAPKVersion(v string) bool <span class="cov10" title="16">{
        return apkVer.Valid(v)
}</span>

func isLessThanAPKVersion(v1, v2 string) bool <span class="cov10" title="16">{
        apkV1, _ := apkVer.NewVersion(v1)
        apkV2, _ := apkVer.NewVersion(v2)
        return apkV1.LessThan(apkV2)
}</span>

func apkReadResultsManifest(b []byte) ([]string, error) <span class="cov8" title="9">{
        if b == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("nil buffer provided")
        }</span>

        <span class="cov7" title="8">buf := bytes.NewBuffer(b)

        var lines []string
        fs := bufio.NewScanner(buf)
        for fs.Scan() </span><span class="cov9" title="13">{
                lines = append(lines, fs.Text())
        }</span>

        <span class="cov7" title="8">return lines, nil</span>
}

func validateAPKPackageVersions(updates unversioned.UpdatePackages, cmp VersionComparer, resultsBytes []byte, ignoreErrors bool) ([]string, error) <span class="cov6" title="6">{
        lines, err := apkReadResultsManifest(resultsBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Assert apk info list doesn't contain more entries than expected
        <span class="cov6" title="6">if len(lines) &gt; len(updates) </span><span class="cov1" title="1">{
                err = fmt.Errorf("expected %d updates, installed %d", len(updates), len(lines))
                log.Error(err)
                return nil, err
        }</span>

        // Not strictly necessary, but sort the two lists to not take a dependency on the
        // ordering behavior of apk info output
        <span class="cov6" title="5">sort.SliceStable(updates, func(i, j int) bool </span><span class="cov5" title="4">{
                return updates[i].Name &lt; updates[j].Name
        }</span>)
        <span class="cov6" title="5">log.Debugf("Required updates: %s", updates)

        sort.SliceStable(lines, func(i, j int) bool </span><span class="cov5" title="4">{
                return lines[i] &lt; lines[j]
        }</span>)
        <span class="cov6" title="5">log.Debugf("Resulting updates: %s", lines)

        // Walk files and check update name is prefix for file name
        // results.manifest file is expected to the `apk info --installed -v &lt;packages ...&gt;` output for the
        // specified packages in the order they were specified in:
        //
        // &lt;package name&gt;-&lt;version&gt;
        // ...
        var allErrors *multierror.Error
        var errorPkgs []string
        lineIndex := 0
        for _, update := range updates </span><span class="cov8" title="9">{
                expectedPrefix := update.Name + "-"
                if lineIndex &gt;= len(lines) || !strings.HasPrefix(lines[lineIndex], expectedPrefix) </span><span class="cov0" title="0">{
                        log.Warnf("Package %s is not installed, may have been uninstalled during upgrade", update.Name)
                        continue</span>
                }

                // Found a match, trim prefix- to get version string
                <span class="cov8" title="9">version := strings.TrimPrefix(lines[lineIndex], expectedPrefix)
                lineIndex++
                if !cmp.IsValid(version) </span><span class="cov3" title="2">{
                        err := fmt.Errorf("invalid version %s found for package %s", version, update.Name)
                        log.Error(err)
                        errorPkgs = append(errorPkgs, update.Name)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov7" title="7">if cmp.LessThan(version, update.FixedVersion) </span><span class="cov3" title="2">{
                        err = fmt.Errorf("downloaded package %s version %s lower than required %s for update", update.Name, version, update.FixedVersion)
                        log.Error(err)
                        errorPkgs = append(errorPkgs, update.Name)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov6" title="5">log.Infof("Validated package %s version %s meets requested version %s", update.Name, version, update.FixedVersion)</span>
        }

        <span class="cov6" title="5">if ignoreErrors </span><span class="cov3" title="2">{
                return errorPkgs, nil
        }</span>

        <span class="cov4" title="3">return errorPkgs, allErrors.ErrorOrNil()</span>
}

func (am *apkManager) InstallUpdates(ctx context.Context, manifest *unversioned.UpdateManifest, ignoreErrors bool) (*llb.State, []string, error) <span class="cov4" title="3">{
        // If manifest is nil, update all packages
        if manifest == nil </span><span class="cov1" title="1">{
                updatedImageState, _, err := am.upgradePackages(ctx, nil, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return updatedImageState, nil, err
                }</span>
                // add validation in the future
                <span class="cov1" title="1">return updatedImageState, nil, nil</span>
        }

        // Resolve set of unique packages to update
        <span class="cov3" title="2">apkComparer := VersionComparer{isValidAPKVersion, isLessThanAPKVersion}
        updates, err := GetUniqueLatestUpdates(manifest.Updates, apkComparer, ignoreErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov3" title="2">if len(updates) == 0 </span><span class="cov0" title="0">{
                log.Warn("No update packages were specified to apply")
                return &amp;am.config.ImageState, nil, nil
        }</span>
        <span class="cov3" title="2">log.Debugf("latest unique APKs: %v", updates)

        updatedImageState, resultsBytes, err := am.upgradePackages(ctx, updates, ignoreErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Validate that the deployed packages are of the requested version or better
        <span class="cov3" title="2">errPkgs, err := validateAPKPackageVersions(updates, apkComparer, resultsBytes, ignoreErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">return updatedImageState, errPkgs, nil</span>
}

// Patch a regular alpine image with:
//   - sh and apk installed on the image
//   - valid apk db state on the image
func (am *apkManager) upgradePackages(ctx context.Context, updates unversioned.UpdatePackages, ignoreErrors bool) (*llb.State, []byte, error) <span class="cov4" title="3">{
        imageStateCurrent := am.config.ImageState
        if am.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                imageStateCurrent = am.config.PatchedImageState
        }</span>

        <span class="cov4" title="3">apkUpdated := imageStateCurrent.Run(llb.Shlex("apk update"), llb.WithProxy(utils.GetProxy()), llb.IgnoreCache).Root()

        // If updating all packages, check for upgrades before proceeding with patch
        if updates == nil </span><span class="cov1" title="1">{
                checkUpgradable := `sh -c "apk list 2&gt;/dev/null | grep -q "upgradable" || exit 1"`
                apkUpdated = apkUpdated.Run(llb.Shlex(checkUpgradable)).Root()
        }</span>

        <span class="cov4" title="3">var apkInstalled llb.State
        var resultManifestBytes []byte
        var err error
        if updates != nil </span><span class="cov3" title="2">{
                // Add all requested update packages
                // This works around cases where some packages (for example, tiff) require other packages in it's dependency tree to be updated
                const apkAddTemplate = `apk add --no-cache %s`
                pkgStrings := []string{}
                for _, u := range updates </span><span class="cov4" title="3">{
                        pkgStrings = append(pkgStrings, u.Name)
                }</span>
                <span class="cov3" title="2">addCmd := fmt.Sprintf(apkAddTemplate, strings.Join(pkgStrings, " "))
                apkAdded := apkUpdated.Run(llb.Shlex(addCmd), llb.WithProxy(utils.GetProxy())).Root()

                // Install all requested update packages without specifying the version. This works around:
                //  - Reports being slightly out of date, where a newer security revision has displaced the one specified leading to not found errors.
                //  - Reports not specifying version epochs correct (e.g. bsdutils=2.36.1-8+deb11u1 instead of with epoch as 1:2.36.1-8+dev11u1)
                // Note that this keeps the log files from the operation, which we can consider removing as a size optimization in the future.
                const apkInstallTemplate = `apk upgrade --no-cache %s`
                installCmd := fmt.Sprintf(apkInstallTemplate, strings.Join(pkgStrings, " "))
                apkInstalled = apkAdded.Run(llb.Shlex(installCmd), llb.WithProxy(utils.GetProxy())).Root()

                // Write updates-manifest to host for post-patch validation
                const outputResultsTemplate = `sh -c 'apk info --installed -v %s &gt; %s; if [[ $? -ne 0 ]]; then echo "WARN: apk info --installed returned $?"; fi'`
                pkgs := strings.Trim(fmt.Sprintf("%s", pkgStrings), "[]")
                outputResultsCmd := fmt.Sprintf(outputResultsTemplate, pkgs, resultManifest)
                mkFolders := apkInstalled.File(llb.Mkdir(resultsPath, 0o744, llb.WithParents(true)))
                resultsDiff := mkFolders.Dir(resultsPath).Run(llb.Shlex(outputResultsCmd)).AddMount(resultsPath, llb.Scratch())

                resultManifestBytes, err = buildkit.ExtractFileFromState(ctx, am.config.Client, &amp;resultsDiff, resultManifest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        } else<span class="cov1" title="1"> {
                // if updates is not specified, update all packages
                installCmd := `output=$(apk upgrade --no-cache 2&gt;&amp;1); if [ $? -ne 0 ]; then echo "$output" &gt;&gt;error_log.txt; fi`
                apkInstalled = apkUpdated.Run(buildkit.Sh(installCmd), llb.WithProxy(utils.GetProxy())).Root()

                // Validate no errors were encountered if updating all
                if !ignoreErrors </span><span class="cov1" title="1">{
                        apkInstalled = apkInstalled.Run(buildkit.Sh("if [ -s error_log.txt ]; then cat error_log.txt; exit 1; fi")).Root()
                }</span>
        }

        // If the image has been patched before, diff the base image and patched image to retain previous patches
        <span class="cov4" title="3">if am.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                // Diff the base image and patched image to get previous patches
                prevPatchDiff := llb.Diff(am.config.ImageState, am.config.PatchedImageState)

                // Diff the base image and new patches
                newPatchDiff := llb.Diff(apkUpdated, apkInstalled)

                // Merging these two diffs will discard everything in the filesystem that hasn't changed
                // Doing llb.Scratch ensures we can keep everything in the filesystem that has not changed
                combinedPatch := llb.Merge([]llb.State{prevPatchDiff, newPatchDiff})
                squashedPatch := llb.Scratch().File(llb.Copy(combinedPatch, "/", "/"))

                // Merge previous and new patches into the base image
                completePatchMerge := llb.Merge([]llb.State{am.config.ImageState, squashedPatch})

                return &amp;completePatchMerge, resultManifestBytes, nil
        }</span>

        // Diff the installed updates and merge that into the target image
        <span class="cov4" title="3">patchDiff := llb.Diff(apkUpdated, apkInstalled)
        patchMerge := llb.Merge([]llb.State{am.config.ImageState, patchDiff})

        return &amp;patchMerge, resultManifestBytes, nil</span>
}

func (am *apkManager) GetPackageType() string <span class="cov1" title="1">{
        return "apk"
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package pkgmgr

import (
        "bufio"
        "bytes"
        "context"
        _ "embed"
        "encoding/json"
        "fmt"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/hashicorp/go-multierror"
        debVer "github.com/knqyf263/go-deb-version"
        "github.com/moby/buildkit/client/llb"
        ocispecs "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        "github.com/project-copacetic/copacetic/pkg/utils"
        log "github.com/sirupsen/logrus"
)

//go:embed scripts/apt_get_download.sh
var aptGetDownloadScript string

const (
        dpkgLibPath      = "/var/lib/dpkg"
        dpkgStatusPath   = dpkgLibPath + "/status"
        dpkgStatusFolder = dpkgLibPath + "/status.d"
        dpkgDownloadPath = "/var/cache/apt/archives"

        statusdOutputFilename = "statusd_type"
)

type dpkgManager struct {
        config         *buildkit.Config
        workingFolder  string
        isDistroless   bool
        statusdNames   string
        packageInfo    map[string]string
        statusdFileMap map[string]string // Maps package names to their status.d filenames
        osVersion      string
        osType         string
        tempStatusFile string
}

type dpkgStatusType uint

const (
        DPKGStatusNone dpkgStatusType = iota
        DPKGStatusFile
        DPKGStatusDirectory
        DPKGStatusMixed

        DPKGStatusInvalid // must always be the last listed
        Debian            = "debian"
)

func (st dpkgStatusType) String() string <span class="cov5" title="5">{
        switch st </span>{
        case DPKGStatusNone:<span class="cov1" title="1">
                return "DPKGStatusNone"</span>
        case DPKGStatusFile:<span class="cov1" title="1">
                return "DPKGStatusFile"</span>
        case DPKGStatusDirectory:<span class="cov1" title="1">
                return "DPKGStatusDirectory"</span>
        case DPKGStatusMixed:<span class="cov1" title="1">
                return "DPKGStatusMixed"</span>
        }
        <span class="cov1" title="1">return "Undefined dpkgStatusType"</span>
}

// Depending on go-deb-version lib for debian version comparison rules.
// See https://manpages.debian.org/testing/dpkg-dev/deb-version.7.en.html
// describing format: "[epoch:]upstream-version[-debian-revision]".
func isValidDebianVersion(v string) bool <span class="cov6" title="8">{
        return debVer.Valid(v)
}</span>

func isLessThanDebianVersion(v1, v2 string) bool <span class="cov5" title="5">{
        debV1, _ := debVer.NewVersion(v1)
        debV2, _ := debVer.NewVersion(v2)
        return debV1.LessThan(debV2)
}</span>

// Map the target image OSType &amp; OSVersion to an appropriate tooling image.
func getAPTImageName(manifest *unversioned.UpdateManifest, osVersion string, useCachePrefix bool) string <span class="cov3" title="3">{
        version := osVersion
        osType := Debian

        if manifest == nil || manifest.Metadata.OS.Type == Debian </span><span class="cov2" title="2">{
                if version &gt; "12" </span><span class="cov0" title="0">{
                        version = strings.Split("stable", ".")[0] + "-slim"
                }</span> else<span class="cov2" title="2"> {
                        version = strings.Split(version, ".")[0] + "-slim"
                }</span>
        } else<span class="cov1" title="1"> {
                osType = manifest.Metadata.OS.Type
        }</span>

        <span class="cov3" title="3">log.Debugf("Using %s:%s as basis for tooling image", osType, version)
        if !useCachePrefix </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s:%s", osType, version)
        }</span>
        <span class="cov3" title="3">return fmt.Sprintf("%s/%s:%s", imageCachePrefix, osType, version)</span>
}

func getDPKGStatusType(b []byte) dpkgStatusType <span class="cov4" title="4">{
        if len(b) == 0 </span><span class="cov0" title="0">{
                return DPKGStatusNone
        }</span>

        <span class="cov4" title="4">st, err := strconv.ParseUint(string(b), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                st = uint64(DPKGStatusNone)
        }</span>

        // convert ascii digit to byte
        <span class="cov4" title="4">statusType := dpkgStatusType(st)
        if statusType &gt;= DPKGStatusInvalid </span><span class="cov0" title="0">{
                return DPKGStatusInvalid
        }</span>

        <span class="cov4" title="4">return statusType</span>
}

func (dm *dpkgManager) InstallUpdates(ctx context.Context, manifest *unversioned.UpdateManifest, ignoreErrors bool) (*llb.State, []string, error) <span class="cov0" title="0">{
        imagePlatform, err := dm.config.ImageState.GetPlatform(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("unable to get image platform %w", err)
        }</span>

        // Probe for additional information to execute the appropriate update install graphs
        <span class="cov0" title="0">toolImageName := getAPTImageName(manifest, dm.osVersion, true) // check if we can resolve the tool image
        if _, err := tryImage(ctx, toolImageName, dm.config.Client, imagePlatform); err != nil </span><span class="cov0" title="0">{
                toolImageName = getAPTImageName(manifest, dm.osVersion, false)
        }</span>
        <span class="cov0" title="0">if err := dm.probeDPKGStatus(ctx, toolImageName, imagePlatform); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // If manifest nil, update all packages
        <span class="cov0" title="0">if manifest == nil </span><span class="cov0" title="0">{
                if dm.isDistroless </span><span class="cov0" title="0">{
                        updatedImageState, _, err := dm.unpackAndMergeUpdates(ctx, nil, toolImageName, ignoreErrors)
                        if err != nil </span><span class="cov0" title="0">{
                                return updatedImageState, nil, err
                        }</span>
                        <span class="cov0" title="0">return updatedImageState, nil, nil</span>
                }

                <span class="cov0" title="0">updatedImageState, _, err := dm.installUpdates(ctx, nil, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return updatedImageState, nil, err
                }</span>
                <span class="cov0" title="0">return updatedImageState, nil, nil</span>
        }

        // Else update according to specified updates
        // Validate and extract unique updates listed in input manifest
        <span class="cov0" title="0">debComparer := VersionComparer{isValidDebianVersion, isLessThanDebianVersion}
        updates, err := GetUniqueLatestUpdates(manifest.Updates, debComparer, ignoreErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                log.Warn("No update packages were specified to apply")
                return &amp;dm.config.ImageState, nil, nil
        }</span>

        <span class="cov0" title="0">var updatedImageState *llb.State
        var resultManifestBytes []byte
        if dm.isDistroless </span><span class="cov0" title="0">{
                updatedImageState, resultManifestBytes, err = dm.unpackAndMergeUpdates(ctx, updates, toolImageName, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                updatedImageState, resultManifestBytes, err = dm.installUpdates(ctx, updates, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        // Validate that the deployed packages are of the requested version or better
        <span class="cov0" title="0">errPkgs, err := validateDebianPackageVersions(updates, debComparer, resultManifestBytes, ignoreErrors)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return updatedImageState, errPkgs, nil</span>
}

// Probe the target image for:
// - DPKG status type to distinguish between regular and distroless images.
// - Whether status.d contains base64-encoded package names.
func (dm *dpkgManager) probeDPKGStatus(ctx context.Context, toolImage string, platform *ocispecs.Platform) error <span class="cov0" title="0">{
        imageStateCurrent := dm.config.ImageState
        if dm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                imageStateCurrent = dm.config.PatchedImageState
        }</span>

        // Spin up a build tooling container to pull and unpack packages to create patch layer.
        <span class="cov0" title="0">toolingBase := llb.Image(toolImage,
                llb.Platform(*platform),
                llb.ResolveModeDefault,
        )
        updated := toolingBase.Run(
                llb.Shlex("apt-get update"),
                llb.WithProxy(utils.GetProxy()),
                llb.IgnoreCache,
        ).Root()

        const installBusyBoxCmd = "apt-get install busybox-static"
        busyBoxInstalled := updated.Run(llb.Shlex(installBusyBoxCmd), llb.WithProxy(utils.GetProxy())).Root()
        busyBoxApplied := imageStateCurrent.File(llb.Copy(busyBoxInstalled, "/bin/busybox", "/bin/busybox"))
        mkFolders := busyBoxApplied.File(llb.Mkdir(resultsPath, 0o744, llb.WithParents(true)))

        resultsState := mkFolders.Run(
                llb.AddEnv("DPKG_STATUS_PATH", dpkgStatusPath),
                llb.AddEnv("RESULTS_PATH", resultsPath),
                llb.AddEnv("DPKG_STATUS_FOLDER", dpkgStatusFolder),
                llb.AddEnv("RESULT_STATUSD_PATH", filepath.Join(resultsPath, "status.d")),
                llb.AddEnv("DPKG_STATUS_IS_DIRECTORY", fmt.Sprintf("%d", DPKGStatusDirectory)),
                llb.AddEnv("DPKG_STATUS_IS_FILE", fmt.Sprintf("%d", DPKGStatusFile)),
                llb.AddEnv("DPKG_STATUS_IS_UNKNOWN", fmt.Sprintf("%d", DPKGStatusNone)),
                llb.AddEnv("STATUSD_OUTPUT_FILENAME", statusdOutputFilename),
                llb.Args([]string{
                        `/bin/busybox`, `sh`, `-c`, `
                status="$DPKG_STATUS_IS_UNKNOWN"
                if [ -f "$DPKG_STATUS_PATH" ]; then
                    status="$DPKG_STATUS_IS_FILE"
                    cp "$DPKG_STATUS_PATH" "$RESULTS_PATH"
                elif [ -d "$DPKG_STATUS_FOLDER" ]; then
                    status="$DPKG_STATUS_IS_DIRECTORY"
                    ls -1 "$DPKG_STATUS_FOLDER" &gt; "$RESULT_STATUSD_PATH"
                    mv "$DPKG_STATUS_FOLDER"/* "$RESULTS_PATH"
                fi
                echo -n "$status" &gt; "${RESULTS_PATH}/${STATUSD_OUTPUT_FILENAME}"
        `,
                })).AddMount(resultsPath, llb.Scratch())

        typeBytes, err := buildkit.ExtractFileFromState(ctx, dm.config.Client, &amp;resultsState, statusdOutputFilename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">dpkgStatus := getDPKGStatusType(typeBytes)
        switch dpkgStatus </span>{
        case DPKGStatusFile:<span class="cov0" title="0">
                return nil</span>
        case DPKGStatusDirectory:<span class="cov0" title="0">
                statusdNamesBytes, err := buildkit.ExtractFileFromState(ctx, dm.config.Client, &amp;resultsState, "status.d")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dm.statusdNames = strings.ReplaceAll(string(statusdNamesBytes), "\n", " ")
                dm.statusdNames = strings.TrimSpace(dm.statusdNames)

                // Use bufio.Scanner with bytes.NewReader to avoid duplicating the list in memory
                scanner := bufio.NewScanner(bytes.NewReader(statusdNamesBytes))
                packageInfo := make(map[string]string)
                statusdFileMap := make(map[string]string)
                var buffer bytes.Buffer

                for scanner.Scan() </span><span class="cov0" title="0">{
                        name := scanner.Text()
                        fileBytes, err := buildkit.ExtractFileFromState(ctx, dm.config.Client, &amp;resultsState, name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if !strings.HasSuffix(name, ".md5sums") </span><span class="cov0" title="0">{
                                pkgName, pkgVersion, err := GetPackageInfo(string(fileBytes))
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">buffer.Write(fileBytes)
                                buffer.WriteString("\n")

                                packageInfo[pkgName] = pkgVersion
                                statusdFileMap[pkgName] = name</span>
                        }
                }

                <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dm.tempStatusFile = buffer.String()
                dm.packageInfo = packageInfo
                dm.statusdFileMap = statusdFileMap

                log.Infof("Processed status.d: %s", dm.statusdNames)
                dm.isDistroless = true
                return nil</span>
        default:<span class="cov0" title="0">
                err := fmt.Errorf("could not infer DPKG status of target image: %v", dpkgStatus)
                log.Error(err)
                return err</span>
        }
}

func GetPackageInfo(file string) (string, string, error) <span class="cov2" title="2">{
        var packageName string
        var packageVersion string

        packagePattern := regexp.MustCompile(`^Package:\s*(.*)`)
        match := packagePattern.FindStringSubmatch(file)
        if len(match) &gt; 1 </span><span class="cov1" title="1">{
                packageName = match[1]
        }</span> else<span class="cov1" title="1"> {
                return "", "", fmt.Errorf("no package name found for package")
        }</span>

        <span class="cov1" title="1">versionPattern := regexp.MustCompile(`Version:\s*(.*)`)
        match = versionPattern.FindStringSubmatch(file)
        if len(match) &gt; 1 </span><span class="cov1" title="1">{
                packageVersion = match[1]
        }</span> else<span class="cov0" title="0"> {
                return "", "", fmt.Errorf("no version found for package")
        }</span>

        <span class="cov1" title="1">return packageName, packageVersion, nil</span>
}

// Patch a regular debian image with:
//   - sh and apt-get installed on the image
//   - valid dpkg status on the image
//
// Images with neither (i.e. Google Debian Distroless) should be patched with unpackAndMergeUpdates.
func (dm *dpkgManager) installUpdates(ctx context.Context, updates unversioned.UpdatePackages, ignoreErrors bool) (*llb.State, []byte, error) <span class="cov2" title="2">{
        imageStateCurrent := dm.config.ImageState
        if dm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                imageStateCurrent = dm.config.PatchedImageState
        }</span>

        <span class="cov2" title="2">aptGetUpdated := imageStateCurrent.Run(
                llb.Shlex("apt-get update"),
                llb.WithProxy(utils.GetProxy()),
                llb.IgnoreCache,
        ).Root()

        checkUpgradable := `sh -c "apt-get -s upgrade 2&gt;/dev/null | grep -q "^Inst" || exit 1"`
        aptGetUpdated = aptGetUpdated.Run(llb.Shlex(checkUpgradable)).Root()

        // detect held packages and log them
        checkHeldCmd := `sh -c "apt-mark showhold | tee /held.txt"`
        heldState := aptGetUpdated.Run(llb.Shlex(checkHeldCmd)).Root()

        // read that file from the solve output
        heldBytes, err := buildkit.ExtractFileFromState(ctx, dm.config.Client, &amp;heldState, "/held.txt")
        if err == nil &amp;&amp; len(heldBytes) &gt; 0 </span><span class="cov1" title="1">{
                lines := strings.Split(strings.TrimSpace(string(heldBytes)), "\n")
                if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov1" title="1">{
                        log.Warnf("apt-held packages found, not patched by Copa: %v", lines)
                }</span>
        }

        // Install all requested update packages without specifying the version. This works around:
        //  - Reports being slightly out of date, where a newer security revision has displaced the one specified leading to not found errors.
        //  - Reports not specifying version epochs correct (e.g. bsdutils=2.36.1-8+deb11u1 instead of with epoch as 1:2.36.1-8+dev11u1)
        // Note that this keeps the log files from the operation, which we can consider removing as a size optimization in the future.

        <span class="cov2" title="2">var installCmd string
        if updates != nil </span><span class="cov1" title="1">{
                aptGetInstallTemplate := `sh -c "apt-get install --no-install-recommends -y %s &amp;&amp; apt-get clean -y"`
                pkgStrings := []string{}
                for _, u := range updates </span><span class="cov2" title="2">{
                        pkgStrings = append(pkgStrings, u.Name)
                }</span>
                <span class="cov1" title="1">installCmd = fmt.Sprintf(aptGetInstallTemplate, strings.Join(pkgStrings, " "))</span>
        } else<span class="cov1" title="1"> {
                // if updates is not specified, update all packages
                installCmd = `sh -c "output=$(apt-get upgrade -y &amp;&amp; apt-get clean -y &amp;&amp; apt-get autoremove -y 2&gt;&amp;1); if [ $? -ne 0 ]; then echo "$output" &gt;&gt;error_log.txt; fi"`
        }</span>

        <span class="cov2" title="2">aptGetInstalled := aptGetUpdated.Run(llb.Shlex(installCmd), llb.WithProxy(utils.GetProxy())).Root()

        // Validate no errors were encountered if updating all
        if updates == nil &amp;&amp; !ignoreErrors </span><span class="cov1" title="1">{
                aptGetInstalled = aptGetInstalled.Run(buildkit.Sh("if [ -s error_log.txt ]; then cat error_log.txt; exit 1; fi")).Root()
        }</span>

        // Write results.manifest to host for post-patch validation
        <span class="cov2" title="2">const outputResultsTemplate = `sh -c 'grep "^Package:\|^Version:" "%s" &gt;&gt; "%s"'`
        outputResultsCmd := fmt.Sprintf(outputResultsTemplate, dpkgStatusPath, resultManifest)
        resultsWritten := aptGetInstalled.Dir(resultsPath).Run(llb.Shlex(outputResultsCmd)).Root()
        resultsDiff := llb.Diff(aptGetInstalled, resultsWritten)

        resultsBytes, err := buildkit.ExtractFileFromState(ctx, dm.config.Client, &amp;resultsDiff, filepath.Join(resultsPath, resultManifest))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // If the image has been patched before, diff the base image and patched image to retain previous patches
        <span class="cov2" title="2">if dm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                // Diff the base image and patched image to get previous patches
                prevPatchDiff := llb.Diff(dm.config.ImageState, dm.config.PatchedImageState)

                // Diff the base image and new patches
                newPatchDiff := llb.Diff(aptGetUpdated, aptGetInstalled)

                // Merging these two diffs will discard everything in the filesystem that hasn't changed
                // Doing llb.Scratch ensures we can keep everything in the filesystem that has not changed
                combinedPatch := llb.Merge([]llb.State{prevPatchDiff, newPatchDiff})
                squashedPatch := llb.Scratch().File(llb.Copy(combinedPatch, "/", "/"))

                // Merge previous and new patches into the base image
                completePatchMerge := llb.Merge([]llb.State{dm.config.ImageState, squashedPatch})

                return &amp;completePatchMerge, resultsBytes, nil
        }</span>

        // Diff the installed updates and merge that into the target image
        <span class="cov2" title="2">patchDiff := llb.Diff(aptGetUpdated, aptGetInstalled)
        patchMerge := llb.Merge([]llb.State{dm.config.ImageState, patchDiff})

        return &amp;patchMerge, resultsBytes, nil</span>
}

func (dm *dpkgManager) unpackAndMergeUpdates(ctx context.Context, updates unversioned.UpdatePackages, toolImage string, ignoreErrors bool) (*llb.State, []byte, error) <span class="cov0" title="0">{
        imagePlatform, err := dm.config.ImageState.GetPlatform(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("unable to get image platform %w", err)
        }</span>

        // Spin up a build tooling container to fetch and unpack packages to create patch layer.
        // Pull family:version -&gt; need to create version to base image map
        <span class="cov0" title="0">toolingBase := llb.Image(toolImage,
                llb.Platform(*imagePlatform),
                llb.ResolveModeDefault,
        )

        // Run apt-get update &amp;&amp; apt-get download list of updates to target folder
        updated := toolingBase.Run(
                llb.Shlex("apt-get update"),
                llb.WithProxy(utils.GetProxy()),
                llb.IgnoreCache,
        ).Root()

        // Retrieve all package info from image to be patched.
        jsonPackageData, err := getJSONPackageData(dm.packageInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // In the case of update all packages, only update packages that are not already latest version. Store these packages in packages.txt.
        <span class="cov0" title="0">if updates == nil </span><span class="cov0" title="0">{
                updated = updated.Run(
                        llb.AddEnv("PACKAGES_PRESENT", string(jsonPackageData)),
                        llb.Args([]string{
                                `bash`, `-c`, `
                                                        json_str=$PACKAGES_PRESENT
                                                        update_packages=""

                                                        while IFS=':' read -r package version; do
                                                                pkg_name=$(echo "$package" | sed 's/^"\(.*\)"$/\1/')
                                                                pkg_version=$(echo "$version" | sed 's/^"\(.*\)"$/\1/')
                                                                latest_version=$(apt show $pkg_name 2&gt;/dev/null | awk -F ': ' '/Version:/{print $2}')

                                                                if [ "$latest_version" != "$pkg_version" ]; then
                                                                        update_packages="$update_packages $pkg_name"
                                                                fi
                                                        done &lt;&lt;&lt; "$(echo "$json_str" | tr -d '{}\n' | tr ',' '\n')"

                                                        if [ -z "$update_packages" ]; then
                                                                echo "No packages to update"
                                                                exit 1
                                                        fi

                                                        mkdir /var/cache/apt/archives
                                                        cd /var/cache/apt/archives
                                                        echo "$update_packages" &gt; packages.txt
                                        `,
                        })).Root()
        }</span>

        // Replace status file in tooling image with new status file with relevant pacakges from image to be patched.
        // Regenerate /var/lib/dpkg/info files based on relevant pacakges from image to be patched.
        <span class="cov0" title="0">dpkgdb := updated.Run(
                llb.AddEnv("PACKAGES_PRESENT_ALL", string(jsonPackageData)),
                llb.AddEnv("STATUS_FILE", dm.tempStatusFile),
                llb.Args([]string{
                        `bash`, `-xec`, `
                                                        set -ex

                                                        json_str=$PACKAGES_PRESENT_ALL

                                                        rm -r /var/lib/dpkg/info
                                                        mkdir -p /var/lib/dpkg/info

                                                        apt-get update

                                                        while IFS=':' read -r package version; do
                                                                pkg_name=$(echo "$package" | sed 's/^"\(.*\)"$/\1/')
                                                                apt-get install --reinstall -y $pkg_name
                                                        done &lt;&lt;&lt; "$(echo "$json_str" | tr -d '{}\n' | tr ',' '\n')"

                                                        apt --fix-broken install
                                                        dpkg --configure -a
                                                        apt-get check

                                                        echo "$STATUS_FILE" &gt; /var/lib/dpkg/status
                                                        ls -lh /var/lib/dpkg
                                                `,
                })).Root()

        // Download all requested update packages without specifying the version. This works around:
        //  - Reports being slightly out of date, where a newer security revision has displaced the one specified leading to not found errors.
        //  - Reports not specifying version epochs correct (e.g. bsdutils=2.36.1-8+deb11u1 instead of with epoch as 1:2.36.1-8+dev11u1)
        var downloadCmd string
        pkgStrings := []string{}
        var updateAll string
        if updates != nil </span><span class="cov0" title="0">{
                for _, u := range updates </span><span class="cov0" title="0">{
                        pkgStrings = append(pkgStrings, u.Name)
                }</span>
                <span class="cov0" title="0">downloadCmd = fmt.Sprintf(aptGetDownloadScript, strings.Join(pkgStrings, " "))
                updateAll = "false"</span>
        } else<span class="cov0" title="0"> {
                downloadCmd = aptGetDownloadScript
                updateAll = "true"
        }</span>

        <span class="cov0" title="0">errorValidation := "false"
        if ignoreErrors </span><span class="cov0" title="0">{
                errorValidation = "true"
        }</span>

        <span class="cov0" title="0">jsonStatusdFileMap, err := getJSONStatusdFileMap(dm.statusdFileMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">updated = updated.File(llb.Mkfile("download.sh", 0o777, []byte(downloadCmd)))

        withDPkgStatus := dm.config.ImageState.
                File(llb.Rm("/var/lib/dpkg")).
                File(
                        llb.Copy(dpkgdb, "/var/lib/dpkg", "/var/lib/dpkg"),
                )

        // Mount image rootfs into tooling image.
        // Now, when Copa does dpkg install into the temp rootfs, it wont get override any config files since they are already there.
        downloaded := updated.Run(
                llb.AddEnv("IGNORE_ERRORS", errorValidation),
                llb.AddEnv("UPDATE_ALL", updateAll),
                llb.AddEnv("STATUSD_FILE_MAP", string(jsonStatusdFileMap)),
                buildkit.Sh(`./download.sh`),
                llb.WithProxy(utils.GetProxy()),
        ).AddMount("/tmp/debian-rootfs", withDPkgStatus)

        resultBytes, err := buildkit.ExtractFileFromState(ctx, dm.config.Client, &amp;downloaded, "/manifest")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">withoutManifest := downloaded.File(llb.Rm("/manifest"))
        diffBase := llb.Diff(dm.config.ImageState, withoutManifest)
        downloaded = llb.Merge([]llb.State{diffBase, withoutManifest})

        // If the image has been patched before, diff the base image and patched image to retain previous patches
        if dm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                // Diff the base image and patched image to get previous patches
                prevPatchDiff := llb.Diff(dm.config.ImageState, dm.config.PatchedImageState)

                // Merging these two diffs will discard everything in the filesystem that hasn't changed
                // Doing llb.Scratch ensures we can keep everything in the filesystem that has not changed
                combinedPatch := llb.Merge([]llb.State{prevPatchDiff, downloaded})
                squashedPatch := llb.Scratch().File(llb.Copy(combinedPatch, "/", "/"))

                // Merge previous and new patches into the base image
                completePatchMerge := llb.Merge([]llb.State{dm.config.ImageState, squashedPatch})

                return &amp;completePatchMerge, resultBytes, nil
        }</span>

        <span class="cov0" title="0">unpacked := llb.Diff(updated, downloaded)
        merged := llb.Merge([]llb.State{llb.Scratch(), dm.config.ImageState, unpacked})

        return &amp;merged, resultBytes, nil</span>
}

func (dm *dpkgManager) GetPackageType() string <span class="cov1" title="1">{
        return "deb"
}</span>

func dpkgParseResultsManifest(b []byte) (map[string]string, error) <span class="cov7" title="12">{
        buf := bytes.NewBuffer(b)

        // results.manifest file is expected to be subset of DPKG status or debian info format
        // consisting of repeating consecutive blocks of:
        //
        // Package: &lt;package name&gt;
        // Version: &lt;version value&gt;
        // ...
        updateMap := map[string]string{}
        fs := bufio.NewScanner(buf)
        var packageName string
        for fs.Scan() </span><span class="cov10" title="34">{
                kv := strings.Split(fs.Text(), " ")
                if len(kv) != 2 </span><span class="cov2" title="2">{
                        err := fmt.Errorf("unexpected %s file entry: %s", resultManifest, fs.Text())
                        log.Error(err)
                        return nil, err
                }</span>
                <span class="cov9" title="32">switch </span>{
                case kv[0] == "Package:":<span class="cov8" title="16">
                        if packageName != "" </span><span class="cov0" title="0">{
                                log.Debugf("ignoring held or not-installed Package without Version: %s", packageName)
                        }</span>
                        <span class="cov8" title="16">packageName = kv[1]</span>
                case kv[0] == "Version:" &amp;&amp; packageName != "":<span class="cov8" title="16">
                        updateMap[packageName] = kv[1]
                        packageName = ""</span>
                default:<span class="cov0" title="0">
                        err := fmt.Errorf("unexpected field found: %s", fs.Text())
                        log.Error(err)
                        return nil, err</span>
                }
        }
        <span class="cov6" title="10">if packageName != "" </span><span class="cov0" title="0">{
                log.Debugf("ignoring held or not-installed Package without Version: %s", packageName)
        }</span>

        <span class="cov6" title="10">return updateMap, nil</span>
}

func validateDebianPackageVersions(updates unversioned.UpdatePackages, cmp VersionComparer, results []byte, ignoreErrors bool) ([]string, error) <span class="cov6" title="8">{
        // Load file into map[string]string for package:version lookup
        updateMap, err := dpkgParseResultsManifest(results)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // for each target package, validate version is mapped version is &gt;= requested version
        <span class="cov5" title="7">var allErrors *multierror.Error
        errorPkgs := []string{}
        for _, update := range updates </span><span class="cov5" title="6">{
                version, ok := updateMap[update.Name]
                if !ok </span><span class="cov1" title="1">{
                        log.Warnf("Package %s is not installed, may have been uninstalled during upgrade", update.Name)
                        continue</span>
                }
                <span class="cov5" title="5">if !cmp.IsValid(version) </span><span class="cov0" title="0">{
                        err := fmt.Errorf("invalid version %s found for package %s", version, update.Name)
                        log.Error(err)
                        errorPkgs = append(errorPkgs, update.Name)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov5" title="5">if cmp.LessThan(version, update.FixedVersion) </span><span class="cov2" title="2">{
                        err = fmt.Errorf("downloaded package %s version %s lower than required %s for update", update.Name, version, update.FixedVersion)
                        log.Error(err)
                        errorPkgs = append(errorPkgs, update.Name)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov3" title="3">log.Infof("Validated package %s version %s meets requested version %s", update.Name, version, update.FixedVersion)</span>
        }

        <span class="cov5" title="7">if ignoreErrors </span><span class="cov2" title="2">{
                return errorPkgs, nil
        }</span>

        <span class="cov5" title="5">return errorPkgs, allErrors.ErrorOrNil()</span>
}

func getJSONStatusdFileMap(statusdFileMap map[string]string) ([]byte, error) <span class="cov0" title="0">{
        jsonBytes, err := json.Marshal(statusdFileMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to marshal statusd file map to JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return jsonBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package pkgmgr

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "sort"

        "github.com/hashicorp/go-multierror"
        "github.com/moby/buildkit/client/llb"
        "github.com/moby/buildkit/frontend/gateway/client"
        ocispecs "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        log "github.com/sirupsen/logrus"
)

const (
        copaPrefix       = "copa-"
        inputPath        = "/" + copaPrefix + "input"
        resultsPath      = "/" + copaPrefix + "out"
        downloadPath     = "/" + copaPrefix + "downloads"
        unpackPath       = "/" + copaPrefix + "unpacked"
        resultManifest   = "results.manifest"
        imageCachePrefix = "ghcr.io/project-copacetic/copacetic"
)

type PackageManager interface {
        InstallUpdates(context.Context, *unversioned.UpdateManifest, bool) (*llb.State, []string, error)
        GetPackageType() string
}

func GetPackageManager(osType string, osVersion string, config *buildkit.Config, workingFolder string) (PackageManager, error) <span class="cov7" title="7">{
        switch osType </span>{
        case "alpine":<span class="cov1" title="1">
                return &amp;apkManager{
                        config:        config,
                        workingFolder: workingFolder,
                }, nil</span>
        case "debian", "ubuntu":<span class="cov3" title="2">
                return &amp;dpkgManager{
                        config:        config,
                        workingFolder: workingFolder,
                        osVersion:     osVersion,
                        osType:        osType,
                }, nil</span>
        case "cbl-mariner", "azurelinux", "centos", "oracle", "redhat", "rocky", "amazon", "alma", "almalinux":<span class="cov4" title="3">
                return &amp;rpmManager{
                        config:        config,
                        workingFolder: workingFolder,
                        osType:        osType,
                        osVersion:     osVersion,
                }, nil</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported osType %s specified", osType)</span>
        }
}

// Utility functions for package manager implementations to share

type VersionComparer struct {
        IsValid  func(string) bool
        LessThan func(string, string) bool
}

func GetUniqueLatestUpdates(updates unversioned.UpdatePackages, cmp VersionComparer, ignoreErrors bool) (unversioned.UpdatePackages, error) <span class="cov7" title="9">{
        if len(updates) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("no patchable vulnerabilities found")
        }</span>

        <span class="cov7" title="8">dict := make(map[string]string)
        var allErrors *multierror.Error
        for _, u := range updates </span><span class="cov10" title="17">{
                if cmp.IsValid(u.FixedVersion) </span><span class="cov9" title="13">{
                        ver, ok := dict[u.Name]
                        if !ok </span><span class="cov7" title="8">{
                                dict[u.Name] = u.FixedVersion
                        }</span> else<span class="cov6" title="5"> if cmp.LessThan(ver, u.FixedVersion) </span><span class="cov3" title="2">{
                                dict[u.Name] = u.FixedVersion
                        }</span>
                } else<span class="cov5" title="4"> {
                        err := fmt.Errorf("invalid version %s found for package %s", u.FixedVersion, u.Name)
                        log.Error(err)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
        }
        <span class="cov7" title="8">if allErrors != nil &amp;&amp; !ignoreErrors </span><span class="cov1" title="1">{
                return nil, allErrors.ErrorOrNil()
        }</span>

        <span class="cov7" title="7">out := unversioned.UpdatePackages{}
        for k, v := range dict </span><span class="cov7" title="8">{
                out = append(out, unversioned.UpdatePackage{Name: k, FixedVersion: v})
        }</span>
        <span class="cov7" title="7">sort.Slice(out, func(i, j int) bool </span><span class="cov3" title="2">{
                return out[i].Name &lt; out[j].Name
        }</span>)
        <span class="cov7" title="7">return out, nil</span>
}

type UpdatePackageInfo struct {
        Filename string
        Version  string
}

type PackageInfoReader interface {
        GetVersion(string) (string, error)
        GetName(string) (string, error)
}

type UpdateMap map[string]*UpdatePackageInfo

func GetValidatedUpdatesMap(updates unversioned.UpdatePackages, cmp VersionComparer, reader PackageInfoReader, stagingPath string) (UpdateMap, error) <span class="cov0" title="0">{
        m := make(UpdateMap)
        for _, update := range updates </span><span class="cov0" title="0">{
                m[update.Name] = &amp;UpdatePackageInfo{Version: update.FixedVersion}
        }</span>

        <span class="cov0" title="0">files, err := os.ReadDir(stagingPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                log.Warn("No downloaded packages to install")
                return nil, nil
        }</span>

        <span class="cov0" title="0">var allErrors *multierror.Error
        for _, file := range files </span><span class="cov0" title="0">{
                name, err := reader.GetName(file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov0" title="0">version, err := reader.GetVersion(file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov0" title="0">if !cmp.IsValid(version) </span><span class="cov0" title="0">{
                        err := fmt.Errorf("invalid version %s found for package %s", version, name)
                        log.Error(err)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }

                <span class="cov0" title="0">p, ok := m[name]
                if !ok </span><span class="cov0" title="0">{
                        log.Warnf("Unexpected: ignoring downloaded update package %s not specified in report", name)
                        os.Remove(filepath.Join(stagingPath, file.Name()))
                        continue</span>
                }

                <span class="cov0" title="0">if cmp.LessThan(version, p.Version) </span><span class="cov0" title="0">{
                        err = fmt.Errorf("downloaded package %s version %s lower than required %s for update", name, version, p.Version)
                        log.Error(err)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov0" title="0">p.Filename = file.Name()</span>
        }

        <span class="cov0" title="0">if allErrors != nil </span><span class="cov0" title="0">{
                return nil, allErrors.ErrorOrNil()
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// tryImage attempts to create an llb.Image reference and call c.Solve() on it
// to confirm it exists. If it doesn't, it will return an error so we can fallback.
func tryImage(ctx context.Context, imageRef string, c client.Client, platform *ocispecs.Platform) (llb.State, error) <span class="cov0" title="0">{
        imageOpts := []llb.ImageOption{
                llb.ResolveModeDefault,
        }
        if platform != nil </span><span class="cov0" title="0">{
                imageOpts = append(imageOpts, llb.Platform(*platform))
        }</span>
        <span class="cov0" title="0">st := llb.Image(
                imageRef,
                imageOpts...,
        )
        def, err := st.Marshal(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return llb.State{}, err
        }</span>

        // Evaluate the solve to see if BuildKit can actually resolve it
        <span class="cov0" title="0">_, err = c.Solve(ctx, client.SolveRequest{
                Definition: def.ToPB(),
                Evaluate:   true,
        })
        if err != nil </span><span class="cov0" title="0">{
                return llb.State{}, fmt.Errorf("failed to resolve %s: %w", imageRef, err)
        }</span>
        <span class="cov0" title="0">return st, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package pkgmgr

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "path/filepath"
        "sort"
        "strings"
        "unicode"

        "github.com/hashicorp/go-multierror"
        rpmVer "github.com/knqyf263/go-rpm-version"
        "github.com/moby/buildkit/client/llb"
        ocispecs "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/project-copacetic/copacetic/pkg/buildkit"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        "github.com/project-copacetic/copacetic/pkg/utils"
        log "github.com/sirupsen/logrus"
        "k8s.io/apimachinery/pkg/util/sets"
)

const (
        rpmToolsFile        = "rpmTools"
        rpmDBFile           = "rpmDB"
        rpmLibPath          = "/var/lib/rpm"
        rpmSQLLiteDB        = "rpmdb.sqlite"
        rpmNDB              = "Packages.db"
        rpmBDB              = "Packages"
        rpmManifestPath     = "/var/lib/rpmmanifest"
        rpmManifest1        = "container-manifest-1"
        rpmManifest2        = "container-manifest-2"
        rpmManifestWildcard = "container-manifest-*"
        falseConst          = "false"
        trueConst           = "true"

        resultQueryFormat = "%{NAME}\t%{VERSION}-%{RELEASE}\t%{ARCH}\n"
)

type rpmToolPaths map[string]string

type rpmManager struct {
        config        *buildkit.Config
        workingFolder string
        rpmTools      rpmToolPaths
        isDistroless  bool
        packageInfo   map[string]string
        osType        string
        osVersion     string
}

type rpmDBType uint

const (
        RPMDBNone rpmDBType = iota
        RPMDBBerkley
        RPMDBNative
        RPMDBSqlLite
        RPMDBManifests
        RPMDBMixed
        RPMDBInvalid // must be the last in the list

        RPMDBSize = RPMDBInvalid
)

func (st rpmDBType) String() string <span class="cov4" title="7">{
        switch st </span>{
        case RPMDBNone:<span class="cov1" title="1">
                return "RPMDBNone"</span>
        case RPMDBBerkley:<span class="cov1" title="1">
                return "RPMDBBerkley"</span>
        case RPMDBNative:<span class="cov1" title="1">
                return "RPMDBNative"</span>
        case RPMDBSqlLite:<span class="cov1" title="1">
                return "RPMDBSqlLite"</span>
        case RPMDBManifests:<span class="cov1" title="1">
                return "RPMDBManifests"</span>
        case RPMDBMixed:<span class="cov1" title="1">
                return "RPMDBMixed"</span>
        }
        <span class="cov1" title="1">return "Undefined rpmDBType"</span>
}

// Depending on go-rpm-version lib for RPM version comparison rules.
func isValidRPMVersion(v string) bool <span class="cov4" title="6">{ // nolint:revive
        err := isValidVersion(v)
        return err == nil
}</span>

func isValidVersion(ver string) error <span class="cov5" title="14">{
        if !unicode.IsDigit(rune(ver[0])) </span><span class="cov1" title="1">{
                return errors.New("upstream_version must start with digit")
        }</span>

        <span class="cov5" title="13">allowedSymbols := ".-+~:_"
        for _, s := range ver </span><span class="cov10" title="143">{
                if !unicode.IsDigit(s) &amp;&amp; !unicode.IsLetter(s) &amp;&amp; !strings.ContainsRune(allowedSymbols, s) </span><span class="cov2" title="2">{
                        return fmt.Errorf("upstream_version %s includes invalid character %q", ver, s)
                }</span>
        }
        <span class="cov5" title="11">return nil</span>
}

func isLessThanRPMVersion(v1, v2 string) bool <span class="cov5" title="14">{
        rpmV1 := rpmVer.NewVersion(v1)
        rpmV2 := rpmVer.NewVersion(v2)
        return rpmV1.LessThan(rpmV2)
}</span>

// Map the target image OSType &amp; OSVersion to an appropriate tooling image.
func getRPMImageName(manifest *unversioned.UpdateManifest, osType string, osVersion string, useCachePrefix bool) string <span class="cov4" title="8">{
        var image, version string

        if osType == "azurelinux" </span><span class="cov2" title="3">{
                image = "azurelinux/base/core"
                if strings.Contains(osVersion, "3.0") </span><span class="cov2" title="2">{
                        version = "3.0"
                }</span> else<span class="cov1" title="1"> {
                        version = osVersion
                }</span>
        } else<span class="cov3" title="5"> {
                // Standardize on cbl-mariner as tooling image base as redhat/ubi does not provide static busybox binary
                image = "cbl-mariner/base/core"
                version = "2.0"

                if manifest != nil &amp;&amp; manifest.Metadata.OS.Type == "cbl-mariner" </span><span class="cov2" title="3">{
                        vers := strings.Split(manifest.Metadata.OS.Version, ".")
                        if len(vers) &lt; 2 </span><span class="cov1" title="1">{
                                vers = append(vers, "0")
                        }</span>
                        <span class="cov2" title="3">version = fmt.Sprintf("%s.%s", vers[0], vers[1])</span>
                }
        }

        <span class="cov4" title="8">log.Debugf("Using %s:%s as basis for tooling image", image, version)

        imagePrefix := "mcr.microsoft.com"
        if useCachePrefix </span><span class="cov4" title="8">{
                imagePrefix = imageCachePrefix
        }</span>
        <span class="cov4" title="8">return fmt.Sprintf("%s/%s:%s", imagePrefix, image, version)</span>
}

func parseRPMTools(b []byte) (rpmToolPaths, error) <span class="cov1" title="1">{
        buf := bytes.NewBuffer(b)
        // rpmTools file is expected contain a string map in the format of:
        // &lt;tool name&gt;:&lt;tool path | `notfound`&gt;
        // ...
        rpmTools := rpmToolPaths{}
        fs := bufio.NewScanner(buf)
        for fs.Scan() </span><span class="cov2" title="3">{
                kv := strings.Split(fs.Text(), `:`)
                if len(kv) != 2 </span><span class="cov0" title="0">{
                        err := fmt.Errorf("unexpected %s file entry: %s", rpmToolsFile, fs.Text())
                        log.Error(err)
                        return nil, err
                }</span>
                <span class="cov2" title="3">if kv[1] != "notfound" &amp;&amp; kv[1] != "" </span><span class="cov2" title="2">{
                        rpmTools[kv[0]] = kv[1]
                }</span>
        }
        <span class="cov1" title="1">return rpmTools, nil</span>
}

// Check the RPM DB type given image probe results.
func getRPMDBType(b []byte) rpmDBType <span class="cov3" title="4">{
        buf := bytes.NewBuffer(b)
        s := bufio.NewScanner(buf)

        set := sets.New[string]()
        for s.Scan() </span><span class="cov3" title="5">{
                fullPath := s.Text()
                base := filepath.Base(fullPath)
                set.Insert(base)
        }</span>

        <span class="cov3" title="4">rpmDBs := make([]rpmDBType, 0, RPMDBSize)

        if set.Has(rpmBDB) </span><span class="cov2" title="2">{
                rpmDBs = append(rpmDBs, RPMDBBerkley)
        }</span>

        <span class="cov3" title="4">if set.Has(rpmNDB) </span><span class="cov1" title="1">{
                rpmDBs = append(rpmDBs, RPMDBNative)
        }</span>

        <span class="cov3" title="4">if set.Has(rpmSQLLiteDB) </span><span class="cov0" title="0">{
                rpmDBs = append(rpmDBs, RPMDBSqlLite)
        }</span>

        <span class="cov3" title="4">if set.Has(rpmManifest1) &amp;&amp; set.Has(rpmManifest2) </span><span class="cov1" title="1">{
                rpmDBs = append(rpmDBs, RPMDBManifests)
        }</span>

        <span class="cov3" title="4">switch len(rpmDBs) </span>{
        case 0:<span class="cov1" title="1">
                return RPMDBNone</span>
        case 1:<span class="cov2" title="2">
                return rpmDBs[0]</span>
        default:<span class="cov1" title="1">
                return RPMDBMixed</span>
        }
}

func (rm *rpmManager) InstallUpdates(ctx context.Context, manifest *unversioned.UpdateManifest, ignoreErrors bool) (*llb.State, []string, error) <span class="cov0" title="0">{
        // Resolve set of unique packages to update if UpdateManifest provided, else update all
        var updates unversioned.UpdatePackages
        var rpmComparer VersionComparer
        var err error

        if manifest != nil </span><span class="cov0" title="0">{
                if manifest.Metadata.OS.Type == "oracle" &amp;&amp; !ignoreErrors </span><span class="cov0" title="0">{
                        err = errors.New("detected Oracle image passed in\n" +
                                "Please read https://project-copacetic.github.io/copacetic/website/troubleshooting before patching your Oracle image")
                        return &amp;rm.config.ImageState, nil, err
                }</span>

                <span class="cov0" title="0">rpmComparer = VersionComparer{isValidRPMVersion, isLessThanRPMVersion}
                updates, err = GetUniqueLatestUpdates(manifest.Updates, rpmComparer, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                        log.Warn("No update packages were specified to apply")
                        return &amp;rm.config.ImageState, nil, nil
                }</span>
                <span class="cov0" title="0">log.Debugf("latest unique RPMs: %v", updates)</span>
        }

        <span class="cov0" title="0">imagePlatform, err := rm.config.ImageState.GetPlatform(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("unable to get image platform")
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">toolImageName := getRPMImageName(manifest, rm.osType, rm.osVersion, true)
        // check if we can resolve the tool image
        if _, err := tryImage(ctx, toolImageName, rm.config.Client, imagePlatform); err != nil </span><span class="cov0" title="0">{
                toolImageName = getRPMImageName(manifest, rm.osType, rm.osVersion, false)
        }</span>

        <span class="cov0" title="0">if err := rm.probeRPMStatus(ctx, toolImageName, imagePlatform); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">var updatedImageState *llb.State
        var resultManifestBytes []byte
        if rm.isDistroless </span><span class="cov0" title="0">{
                updatedImageState, resultManifestBytes, err = rm.unpackAndMergeUpdates(ctx, updates, toolImageName, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                updatedImageState, resultManifestBytes, err = rm.installUpdates(ctx, updates, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov0" title="0">var errPkgs []string
        if manifest != nil </span><span class="cov0" title="0">{
                // Validate that the deployed packages are of the requested version or better
                errPkgs, err = validateRPMPackageVersions(updates, rpmComparer, resultManifestBytes, ignoreErrors)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov0" title="0">return updatedImageState, errPkgs, nil</span>
}

func (rm *rpmManager) probeRPMStatus(ctx context.Context, toolImage string, platform *ocispecs.Platform) error <span class="cov0" title="0">{
        imageStateCurrent := rm.config.ImageState
        if rm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                imageStateCurrent = rm.config.PatchedImageState
        }</span>

        // Spin up a build tooling container to pull and unpack packages to create patch layer.
        <span class="cov0" title="0">toolingBase := llb.Image(toolImage,
                llb.Platform(*platform),
                llb.ResolveModeDefault,
        )

        // List all packages installed in the tooling image
        toolsListed := toolingBase.Run(llb.Shlex(`sh -c 'ls /usr/bin &gt; applications.txt'`)).Root()
        installToolsCmd, err := rm.generateToolInstallCmd(ctx, &amp;toolsListed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">packageManagers := []string{"tdnf", "dnf", "microdnf", "yum", "rpm"}

        toolsInstalled := toolingBase.Run(llb.Shlex(installToolsCmd), llb.WithProxy(utils.GetProxy())).Root()
        toolsApplied := imageStateCurrent.File(llb.Copy(toolsInstalled, "/usr/sbin/busybox", "/usr/sbin/busybox"))
        mkFolders := toolsApplied.
                File(llb.Mkdir(resultsPath, 0o744, llb.WithParents(true))).
                File(llb.Mkdir(inputPath, 0o744, llb.WithParents(true)))

        rpmDBList := []string{
                filepath.Join(rpmLibPath, rpmBDB),
                filepath.Join(rpmLibPath, rpmNDB),
                filepath.Join(rpmLibPath, rpmSQLLiteDB),
                filepath.Join(rpmManifestPath, rpmManifest1),
                filepath.Join(rpmManifestPath, rpmManifest2),
        }

        toolListPath := filepath.Join(inputPath, "tool_list")
        dbListPath := filepath.Join(inputPath, "rpm_db_list")

        probed := buildkit.WithArrayFile(&amp;mkFolders, toolListPath, packageManagers)
        probed = buildkit.WithArrayFile(&amp;probed, dbListPath, rpmDBList)
        outState := probed.Run(
                llb.AddEnv("TOOL_LIST_PATH", toolListPath),
                llb.AddEnv("DB_LIST_PATH", dbListPath),
                llb.AddEnv("RESULTS_PATH", resultsPath),
                llb.AddEnv("RPM_TOOLS_OUTPUT_FILENAME", rpmToolsFile),
                llb.AddEnv("RPM_DB_LIST_OUTPUT_FILENAME", rpmDBFile),
                llb.AddEnv("BUSYBOX", "/usr/sbin/busybox"),
                llb.Args([]string{
                        `/usr/sbin/busybox`, `sh`, `-c`, `
                while IFS= read -r tool; do
                    tool_path="$($BUSYBOX which "$tool")"
                    echo "${tool}:${tool_path:-notfound}" &gt;&gt; "${RESULTS_PATH}/${RPM_TOOLS_OUTPUT_FILENAME}"
                done &lt; "$TOOL_LIST_PATH"

                while IFS= read -r db; do
                    echo "$db"
                    if [ -f "$db" ]; then
                        $BUSYBOX cp "$db" "$RESULTS_PATH"
                        echo "$db" &gt;&gt; "${RESULTS_PATH}/${RPM_DB_LIST_OUTPUT_FILENAME}"
                    fi
                done &lt; "$DB_LIST_PATH"
            `,
                })).AddMount(resultsPath, llb.Scratch())

        rpmDBListOutputBytes, err := buildkit.ExtractFileFromState(ctx, rm.config.Client, &amp;outState, rpmDBFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check type of RPM DB on image to infer Mariner Distroless
        <span class="cov0" title="0">rpmDB := getRPMDBType(rpmDBListOutputBytes)
        log.Debugf("RPM DB Type in image is: %s", rpmDB)
        switch rpmDB </span>{
        case RPMDBManifests:<span class="cov0" title="0">
                rm.isDistroless = true
                rpmManifest2File, err := buildkit.ExtractFileFromState(ctx, rm.config.Client, &amp;outState, rpmManifest2)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // parse container-manifest-2 to get installed package names and versions
                <span class="cov0" title="0">pkgInfo, err := parseManifestFile(string(rpmManifest2File))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">rm.packageInfo = pkgInfo</span>
        case RPMDBNone, RPMDBMixed:<span class="cov0" title="0">
                err := fmt.Errorf("could not find determine RPM DB type of target image: %v", rpmDB)
                log.Error(err)
                return err</span>
        }

        // Parse rpmTools File if not distroless
        <span class="cov0" title="0">if !rm.isDistroless </span><span class="cov0" title="0">{
                log.Info("Checking for available RPM tools in non-distroless image ...")

                toolsFileBytes, err := buildkit.ExtractFileFromState(ctx, rm.config.Client, &amp;outState, rpmToolsFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">rpmTools, err := parseRPMTools(toolsFileBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var allErrors *multierror.Error
                if rpmTools["tdnf"] == "" &amp;&amp; rpmTools["dnf"] == "" &amp;&amp; rpmTools["yum"] == "" &amp;&amp; rpmTools["microdnf"] == "" </span><span class="cov0" title="0">{
                        err = errors.New("image contains no RPM package managers needed for patching")
                        log.Error(err)
                        allErrors = multierror.Append(allErrors, err)
                }</span>
                <span class="cov0" title="0">if rpmTools["rpm"] == "" </span><span class="cov0" title="0">{
                        err = errors.New("image does not have the rpm tool needed for patch verification")
                        log.Error(err)
                        allErrors = multierror.Append(allErrors, err)
                }</span>
                <span class="cov0" title="0">if allErrors != nil </span><span class="cov0" title="0">{
                        return allErrors.ErrorOrNil()
                }</span>

                <span class="cov0" title="0">rm.rpmTools = rpmTools</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (rm *rpmManager) generateToolInstallCmd(ctx context.Context, toolsListed *llb.State) (string, error) <span class="cov2" title="3">{
        applicationsList, err := buildkit.ExtractFileFromState(ctx, rm.config.Client, toolsListed, "/applications.txt")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // packageManagersInstalled is the package manager(s) available within the tooling image
        // RPM must be excluded from this list as it cannot connect to RPM repos
        <span class="cov2" title="3">var packageManagersInstalled []string
        packageManagerList := []string{"tdnf", "dnf", "microdnf", "yum"}

        for _, packageManager := range packageManagerList </span><span class="cov5" title="12">{
                if strings.Contains(string(applicationsList), packageManager) </span><span class="cov4" title="6">{
                        packageManagersInstalled = append(packageManagersInstalled, packageManager)
                }</span>
        }

        // missingTools indicates which tools, if any, need to be installed within the tooling image
        <span class="cov2" title="3">var missingTools []string
        requiredToolingList := []string{"busybox", "dnf-utils", "cpio"}

        for _, tool := range requiredToolingList </span><span class="cov4" title="9">{
                isMissingTool := !strings.Contains(string(applicationsList), tool)
                if isMissingTool </span><span class="cov4" title="9">{
                        missingTools = append(missingTools, tool)
                }</span>

                <span class="cov4" title="9">if tool == "cpio" &amp;&amp; !isMissingTool &amp;&amp; strings.Contains(string(applicationsList), "rpm2cpio") </span><span class="cov0" title="0">{
                        missingTools = append(missingTools, "cpio")
                }</span>
        }

        // A tooling image could contain multiple package managers
        // Choose the first one detected to use in the installation command
        <span class="cov2" title="3">installCmd := fmt.Sprintf("%s install %s -y", packageManagersInstalled[0], strings.Join(missingTools, " "))

        return installCmd, nil</span>
}

func parseManifestFile(file string) (map[string]string, error) <span class="cov3" title="5">{
        // split into lines
        file = strings.TrimSuffix(file, "\n")
        lines := strings.Split(file, "\n")

        resultMap := make(map[string]string)

        // iterate over lines
        for _, line := range lines </span><span class="cov5" title="10">{
                // split line into columns
                columns := strings.Split(line, "\t")

                if len(columns) &gt;= 2 </span><span class="cov4" title="7">{
                        // get package name and version
                        name := columns[0]
                        version := columns[1]
                        resultMap[name] = version
                }</span> else<span class="cov2" title="3"> {
                        return nil, errors.New("unexpected format when parsing rpm manifest file")
                }</span>
        }
        <span class="cov2" title="2">return resultMap, nil</span>
}

// Patch a regular RPM-based image with:
//   - sh and an appropriate tool installed on the image (yum, dnf, microdnf)
//   - valid rpm database on the image
func (rm *rpmManager) installUpdates(ctx context.Context, updates unversioned.UpdatePackages, ignoreErrors bool) (*llb.State, []byte, error) <span class="cov3" title="5">{
        pkgs := ""

        imageStateCurrent := rm.config.ImageState
        if rm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                imageStateCurrent = rm.config.PatchedImageState
        }</span>

        // If specific updates, provided, parse into pkg names, else will update all
        <span class="cov3" title="5">if updates != nil </span><span class="cov1" title="1">{
                // Format the requested updates into a space-separated string
                pkgStrings := []string{}
                for _, u := range updates </span><span class="cov2" title="2">{
                        pkgStrings = append(pkgStrings, u.Name)
                }</span>
                <span class="cov1" title="1">pkgs = strings.Join(pkgStrings, " ")</span>
        }

        // Install patches using available rpm managers in order of preference
        <span class="cov3" title="5">var installCmd string
        switch </span>{
        case rm.rpmTools["tdnf"] != "" || rm.rpmTools["dnf"] != "":<span class="cov2" title="2">
                dnfTooling := rm.rpmTools["tdnf"]
                if dnfTooling == "" </span><span class="cov2" title="2">{
                        dnfTooling = rm.rpmTools["dnf"]
                }</span>
                <span class="cov2" title="2">checkUpdateTemplate := `sh -c '%[1]s clean all &amp;&amp; %[1]s makecache --refresh -y; if [ "$(%[1]s -q check-update | wc -l)" -ne 0 ]; then echo &gt;&gt; /updates.txt; fi'`
                if !rm.checkForUpgrades(ctx, dnfTooling, checkUpdateTemplate) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("no patchable packages found")
                }</span>

                <span class="cov2" title="2">const dnfInstallTemplate = `sh -c '%[1]s upgrade --refresh %[2]s -y &amp;&amp; %[1]s clean all'`
                installCmd = fmt.Sprintf(dnfInstallTemplate, dnfTooling, pkgs)</span>
        case rm.rpmTools["yum"] != "":<span class="cov1" title="1">
                checkUpdateTemplate := `sh -c '%[1]s clean all &amp;&amp; %[1]s makecache fast; if [ "$(%[1]s -q check-update | wc -l)" -ne 0 ]; then echo &gt;&gt; /updates.txt; fi'`
                if !rm.checkForUpgrades(ctx, rm.rpmTools["yum"], checkUpdateTemplate) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("no patchable packages found")
                }</span>

                <span class="cov1" title="1">const yumInstallTemplate = `sh -c '%[1]s upgrade %[2]s -y &amp;&amp; %[1]s clean all'`
                installCmd = fmt.Sprintf(yumInstallTemplate, rm.rpmTools["yum"], pkgs)</span>
        case rm.rpmTools["microdnf"] != "":<span class="cov1" title="1">
                checkUpdateTemplate := `sh -c "%[1]s install dnf -y; dnf clean all &amp;&amp; dnf makecache --refresh -y;  dnf check-update -y; if [ $? -ne 0 ]; then echo &gt;&gt; /updates.txt; fi;"`
                if !rm.checkForUpgrades(ctx, rm.rpmTools["microdnf"], checkUpdateTemplate) </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("no patchable packages found")
                }</span>

                <span class="cov1" title="1">const microdnfInstallTemplate = `sh -c '%[1]s update %[2]s -y &amp;&amp; %[1]s clean all'`
                installCmd = fmt.Sprintf(microdnfInstallTemplate, rm.rpmTools["microdnf"], pkgs)</span>
        default:<span class="cov1" title="1">
                err := errors.New("unexpected: no package manager tools were found for patching")
                return nil, nil, err</span>
        }
        <span class="cov3" title="4">installed := imageStateCurrent.Run(llb.Shlex(installCmd), llb.WithProxy(utils.GetProxy())).Root()

        // Validate no errors were encountered if updating all
        if updates == nil &amp;&amp; !ignoreErrors </span><span class="cov2" title="3">{
                installed = installed.Run(buildkit.Sh("if [ -s error_log.txt ]; then cat error_log.txt; exit 1; fi")).Root()
        }</span>

        // Write results.manifest to host for post-patch validation
        <span class="cov3" title="4">var resultBytes []byte
        if updates != nil </span><span class="cov1" title="1">{
                const rpmResultsTemplate = `sh -c 'rpm -qa --queryformat "%s" %s &gt; "%s"'`
                outputResultsCmd := fmt.Sprintf(rpmResultsTemplate, resultQueryFormat, pkgs, resultManifest)
                resultsWritten := installed.Dir(resultsPath).Run(llb.Shlex(outputResultsCmd)).AddMount(resultsPath, llb.Scratch())

                var err error
                resultBytes, err = buildkit.ExtractFileFromState(ctx, rm.config.Client, &amp;resultsWritten, resultManifest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        // If the image has been patched before, diff the base image and patched image to retain previous patches
        <span class="cov3" title="4">if rm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                // Diff the base image and pat[]ched image to get previous patches
                prevPatchDiff := llb.Diff(rm.config.ImageState, rm.config.PatchedImageState)

                // Diff the base image and new patches
                newPatchDiff := llb.Diff(rm.config.ImageState, installed)

                // Merging these two diffs will discard everything in the filesystem that hasn't changed
                // Doing llb.Scratch ensures we can keep everything in the filesystem that has not changed
                combinedPatch := llb.Merge([]llb.State{prevPatchDiff, newPatchDiff})
                squashedPatch := llb.Scratch().File(llb.Copy(combinedPatch, "/", "/"))

                // Merge previous and new patches into the base image
                completePatchMerge := llb.Merge([]llb.State{rm.config.ImageState, squashedPatch})

                return &amp;completePatchMerge, resultBytes, nil
        }</span>

        // Diff the installed updates and merge that into the target image
        <span class="cov3" title="4">patchDiff := llb.Diff(rm.config.ImageState, installed)
        patchMerge := llb.Merge([]llb.State{rm.config.ImageState, patchDiff})

        return &amp;patchMerge, resultBytes, nil</span>
}

func (rm *rpmManager) checkForUpgrades(ctx context.Context, toolPath, checkUpdateTemplate string) bool <span class="cov3" title="4">{
        imageStateCurrent := rm.config.ImageState
        if rm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                imageStateCurrent = rm.config.PatchedImageState
        }</span>

        <span class="cov3" title="4">checkUpdate := fmt.Sprintf(checkUpdateTemplate, toolPath)
        stateWithCheck := imageStateCurrent.Run(llb.Shlex(checkUpdate)).Root()

        // if error in extracting file, that means updates.txt does not exist and there are no updates.
        _, err := buildkit.ExtractFileFromState(ctx, rm.config.Client, &amp;stateWithCheck, "/updates.txt")

        return err == nil</span>
}

func (rm *rpmManager) unpackAndMergeUpdates(ctx context.Context, updates unversioned.UpdatePackages, toolImage string, ignoreErrors bool) (*llb.State, []byte, error) <span class="cov2" title="3">{
        // Spin up a build tooling container to fetch and unpack packages to create patch layer.
        // Pull family:version -&gt; need to create version to base image map
        toolingBase := llb.Image(toolImage,
                llb.ResolveModeDefault,
        )

        // List all packages installed in the tooling image
        toolsListed := toolingBase.Run(llb.Shlex(`sh -c 'ls /usr/bin &gt; applications.txt'`)).Root()
        installToolsCmd, err := rm.generateToolInstallCmd(ctx, &amp;toolsListed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Install busybox. This should reuse the layer cached from probeRPMStatus.
        <span class="cov2" title="3">toolsInstalled := toolingBase.Run(llb.Shlex(installToolsCmd), llb.WithProxy(utils.GetProxy())).Root()
        busyboxCopied := toolsInstalled.Dir(downloadPath).Run(llb.Shlex("cp /usr/sbin/busybox .")).Root()

        // Retrieve all package info from image to be patched.
        jsonPackageData, err := getJSONPackageData(rm.packageInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // In the case of update all packages, only update packages that are not latest version. Store these packages in packages.txt.
        <span class="cov2" title="3">if updates == nil </span><span class="cov1" title="1">{
                busyboxCopied = busyboxCopied.Run(
                        llb.AddEnv("PACKAGES_PRESENT", string(jsonPackageData)),
                        llb.Args([]string{
                                `bash`, `-c`, `
                                                                json_str=$PACKAGES_PRESENT
                                                                update_packages=""

                                                                while IFS=':' read -r package version; do
                                                                        pkg_name=$(echo "$package" | sed 's/^"\(.*\)"$/\1/')

                                                                        pkg_version=$(echo "$version" | sed 's/^"\(.*\)"$/\1/')
                                                                        latest_version=$(yum list available $pkg_name 2&gt;/dev/null | grep $pkg_name | tail -n 1 | tr -s ' ' | cut -d ' ' -f 2)

                                                                        if [ "$latest_version" != "$pkg_version" ]; then
                                                                                update_packages="$update_packages $pkg_name"
                                                                        fi
                                                                done &lt;&lt;&lt; "$(echo "$json_str" | tr -d '{}\n' | tr ',' '\n')"

                                                                if [ -z "$update_packages" ]; then
                                                                        echo "No packages to update"
                                                                        exit 1
                                                                fi

                                                                echo "$update_packages" &gt; packages.txt
                                                `,
                        })).Root()
        }</span>

        // Create a new state for tooling image with all the packages from the image we are trying to patch
        // this will ensure the rpm database is generate for us to use
        <span class="cov2" title="3">rpmdb := busyboxCopied.Run(
                llb.AddEnv("PACKAGES_PRESENT_ALL", string(jsonPackageData)),
                llb.AddEnv("OS_VERSION", rm.osVersion),
                llb.Args([]string{
                        `bash`, `-xec`, `
                                                                json_str=$PACKAGES_PRESENT_ALL
                                                                packages_formatted=""

                                                                while IFS=':' read -r package version; do
                                                                        pkg_name=$(echo "$package" | sed 's/^"\(.*\)"$/\1/')
                                                                        pkg_version=$(echo "$version" | sed 's/^"\(.*\)"$/\1/')

                                                                        packages_formatted="$packages_formatted $pkg_name-$pkg_version"

                                                                done &lt;&lt;&lt; "$(echo "$json_str" | tr -d '{}\n' | tr ',' '\n')"

                                                                # Convert OS_VERSION from X.Y.Z to X.Y format
                                                                OS_VERSION_XY=$(echo "$OS_VERSION" | cut -d'.' -f1-2)

                                                                tdnf makecache
                                                                tdnf install -y --releasever=$OS_VERSION_XY --installroot=/tmp/rootfs $packages_formatted

                                                                ls /tmp/rootfs/var/lib/rpm
                                                `,
                })).AddMount("/tmp/rootfs/var/lib/rpm", llb.Scratch())

        // Download all requested update packages without specifying the version. This works around:
        //  - Reports being slightly out of date, where a newer security revision has displaced the one specified leading to not found errors.
        //  - Reports not specifying version epochs correct (e.g. bsdutils=2.36.1-8+deb11u1 instead of with epoch as 1:2.36.1-8+dev11u1)
        //  - Reports specifying remediation packages for cbl-mariner v1 instead of v2 (e.g. *.cm1.aarch64 instead of *.cm2.aarch64)
        var downloadCmd string

        if updates != nil </span><span class="cov2" title="2">{
                rpmDownloadTemplate := `
                set -x
                packages="%s"
                echo "$packages"

                mkdir -p /tmp/rootfs/var/lib
                ln -s /tmp/rpmdb /tmp/rootfs/var/lib/rpm

                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa

                for package in $packages; do
                        package="${package%%.*}" # trim anything after the first "."
                        # Convert OS_VERSION from X.Y.Z to X.Y format
                        OS_VERSION_XY=$(echo "$OS_VERSION" | cut -d'.' -f1-2)

                        output=$(tdnf install -y --releasever=$OS_VERSION_XY --installroot=/tmp/rootfs ${package} 2&gt;&amp;1)

                        if [ "$IGNORE_ERRORS" = "false" ] &amp;&amp; [ $? -ne 0 ]; then
                                exit $?
                        fi
                done

                mkdir /tmp/rootfs/var/lib/rpmmanifest

                rpm --dbpath=/tmp/rootfs/var/lib/rpm --erase --allmatches gpg-pubkey-*
                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa | tee /tmp/rootfs/var/lib/rpmmanifest/container-manifest-1
                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa --qf "%%{NAME}\t%%{VERSION}-%%{RELEASE}\t%%{INSTALLTIME}\t%%{BUILDTIME}\t%%{VENDOR}\t%%{EPOCH}\t%%{SIZE}\t%%{ARCH}\t%%{EPOCHNUM}\t%%{SOURCERPM}\n" \
                | tee /tmp/rootfs/var/lib/rpmmanifest/container-manifest-2

                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa
                rm /tmp/rootfs/var/lib/rpm
                rm -rf /tmp/rootfs/var/cache/tdnf

                rpm --dbpath /tmp/rpmdb -qa --qf="%%{NAME}\t%%{VERSION}-%%{RELEASE}\t%%{ARCH}\n" %s &gt; /tmp/rootfs/manifest`

                pkgStrings := []string{}
                for _, u := range updates </span><span class="cov2" title="3">{
                        pkgStrings = append(pkgStrings, u.Name)
                }</span>

                <span class="cov2" title="2">downloadCmd = fmt.Sprintf(rpmDownloadTemplate, strings.Join(pkgStrings, " "), strings.Join(pkgStrings, " "))</span>
        } else<span class="cov1" title="1"> {
                // only updated the outdated packages from packages.txt
                downloadCmd = `
                set -x

                packages=$(&lt;packages.txt)
                echo "$packages"
                mkdir -p /tmp/rootfs/var/lib
                ln -s /tmp/rpmdb /tmp/rootfs/var/lib/rpm

                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa
                for package in $packages; do
                        package="${package%%.*}" # trim anything after the first "."
                        output=$(tdnf install -y --releasever=$OS_VERSION --installroot=/tmp/rootfs ${package} 2&gt;&amp;1)

                        if [ "$IGNORE_ERRORS" = "false" ] &amp;&amp; [ $? -ne 0 ]; then
                                exit $?
                        fi
                done

                mkdir /tmp/rootfs/var/lib/rpmmanifest

                rpm --dbpath=/tmp/rootfs/var/lib/rpm --erase --allmatches gpg-pubkey-*
                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa | tee /tmp/rootfs/var/lib/rpmmanifest/container-manifest-1
                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa --qf '%{NAME}\t%{VERSION}-%{RELEASE}\t%{INSTALLTIME}\t%{BUILDTIME}\t%{VENDOR}\t%{EPOCH}\t%{SIZE}\t%{ARCH}\t%{EPOCHNUM}\t%{SOURCERPM}\n' \
                | tee /tmp/rootfs/var/lib/rpmmanifest/container-manifest-2
                 

                rpm --dbpath=/tmp/rootfs/var/lib/rpm -qa
                rm /tmp/rootfs/var/lib/rpm
                rm -rf /tmp/rootfs/var/cache/tdnf

                rpm --dbpath /tmp/rpmdb -qa --qf="%%{NAME}\t%%{VERSION}-%%{RELEASE}\t%%{ARCH}\n" %s &gt; /tmp/rootfs/manifest`
        }</span>

        <span class="cov2" title="3">errorValidation := falseConst
        if ignoreErrors </span><span class="cov1" title="1">{
                errorValidation = trueConst
        }</span>

        <span class="cov2" title="3">downloaded := busyboxCopied.Run(
                llb.AddEnv("OS_VERSION", rm.osVersion),
                llb.AddEnv("IGNORE_ERRORS", errorValidation),
                buildkit.Sh(downloadCmd),
                llb.WithProxy(utils.GetProxy()),
                llb.AddMount("/tmp/rpmdb", rpmdb),
        ).AddMount("/tmp/rootfs", rm.config.ImageState)

        resultBytes, err := buildkit.ExtractFileFromState(ctx, rm.config.Client, &amp;downloaded, "/manifest")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov2" title="3">withoutManifest := downloaded.File(llb.Rm("/manifest"))
        diffBase := llb.Diff(rm.config.ImageState, withoutManifest)
        downloaded = llb.Merge([]llb.State{diffBase, withoutManifest})

        // If the image has been patched before, diff the base image and patched image to retain previous patches
        if rm.config.PatchedConfigData != nil </span><span class="cov0" title="0">{
                // Diff the base image and patched image to get previous patches
                prevPatchDiff := llb.Diff(rm.config.ImageState, rm.config.PatchedImageState)

                // Merging these two diffs will discard everything in the filesystem that hasn't changed
                // Doing llb.Scratch ensures we can keep everything in the filesystem that has not changed
                combinedPatch := llb.Merge([]llb.State{prevPatchDiff, downloaded})
                squashedPatch := llb.Scratch().File(llb.Copy(combinedPatch, "/", "/"))

                // Merge previous and new patches into the base image
                completePatchMerge := llb.Merge([]llb.State{rm.config.ImageState, squashedPatch})

                return &amp;completePatchMerge, resultBytes, nil
        }</span>

        // Diff unpacked packages layers from previous and merge with target
        <span class="cov2" title="3">diff := llb.Diff(rm.config.ImageState, downloaded)
        merged := llb.Merge([]llb.State{llb.Scratch(), rm.config.ImageState, diff})

        return &amp;merged, resultBytes, nil</span>
}

func (rm *rpmManager) GetPackageType() string <span class="cov1" title="1">{
        return "rpm"
}</span>

func rpmReadResultsManifest(b []byte) ([]string, error) <span class="cov4" title="6">{
        if b == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("nil result manifest buffer")
        }</span>

        <span class="cov3" title="5">buf := bytes.NewBuffer(b)

        var lines []string
        fs := bufio.NewScanner(buf)
        for fs.Scan() </span><span class="cov5" title="10">{
                lines = append(lines, fs.Text())
        }</span>

        <span class="cov3" title="5">return lines, nil</span>
}

func getJSONPackageData(packageInfo map[string]string) ([]byte, error) <span class="cov3" title="4">{
        data, err := json.Marshal(packageInfo)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to marshal rm.packageInfo %w", err)
        }</span>

        <span class="cov3" title="4">return data, nil</span>
}

func validateRPMPackageVersions(updates unversioned.UpdatePackages, cmp VersionComparer, resultsBytes []byte, ignoreErrors bool) ([]string, error) <span class="cov3" title="4">{
        lines, err := rpmReadResultsManifest(resultsBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Not strictly necessary, but sort the two lists to not take a dependency on the
        // ordering behavior of rpm -qa output
        <span class="cov3" title="4">sort.SliceStable(updates, func(i, j int) bool </span><span class="cov2" title="3">{
                return updates[i].Name &lt; updates[j].Name
        }</span>)
        <span class="cov3" title="4">log.Debugf("Required updates: %s", updates)

        sort.SliceStable(lines, func(i, j int) bool </span><span class="cov3" title="4">{
                return lines[i] &lt; lines[j]
        }</span>)
        <span class="cov3" title="4">log.Debugf("Resulting updates: %s", lines)

        // Assert rpm info list doesn't contain more entries than expected
        if len(lines) &gt; len(updates) </span><span class="cov1" title="1">{
                err = fmt.Errorf("expected %d updates, installed %d", len(updates), len(lines))
                log.Error(err)
                return nil, err
        }</span>

        // Walk files and check update name is prefix for file name
        // results.manifest file is expected to the `rpm -qa &lt;packages ...&gt;`
        // using the resultQueryFormat with tab delimiters.
        <span class="cov2" title="3">var allErrors *multierror.Error
        var errorPkgs []string
        lineIndex := 0
        for _, update := range updates </span><span class="cov4" title="6">{
                expectedPrefix := update.Name + "\t"
                if lineIndex &gt;= len(lines) || !strings.HasPrefix(lines[lineIndex], expectedPrefix) </span><span class="cov0" title="0">{
                        log.Warnf("Package %s is not installed, may have been uninstalled during upgrade", update.Name)
                        continue</span>
                }

                // Found a match, trim prefix- and drop the .arch suffix to get version string
                <span class="cov4" title="6">archIndex := strings.LastIndex(lines[lineIndex], "\t")
                version := strings.TrimPrefix(lines[lineIndex][:archIndex], expectedPrefix)
                lineIndex++

                if !cmp.IsValid(version) </span><span class="cov0" title="0">{
                        err := fmt.Errorf("invalid version %s found for package %s", version, update.Name)
                        log.Error(err)
                        errorPkgs = append(errorPkgs, update.Name)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                // Strip epoch from update.Version; report may specify it, but RPM naming scheme does not support epochs
                <span class="cov4" title="6">expectedVersion := update.FixedVersion[strings.Index(update.FixedVersion, ":")+1:]
                if cmp.LessThan(version, expectedVersion) </span><span class="cov3" title="4">{
                        err = fmt.Errorf("downloaded package %s version %s lower than required %s for update", update.Name, version, update.FixedVersion)
                        log.Error(err)
                        errorPkgs = append(errorPkgs, update.Name)
                        allErrors = multierror.Append(allErrors, err)
                        continue</span>
                }
                <span class="cov2" title="2">log.Infof("Validated package %s version %s meets requested version %s", update.Name, version, update.FixedVersion)</span>
        }

        <span class="cov2" title="3">if ignoreErrors </span><span class="cov1" title="1">{
                return errorPkgs, nil
        }</span>

        <span class="cov2" title="2">return errorPkgs, allErrors.ErrorOrNil()</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package report

import (
        "encoding/json"
        "fmt"
        "os"
        "os/exec"

        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
        "github.com/project-copacetic/copacetic/pkg/types/v1alpha1"
)

type ErrorUnsupported struct {
        err error
}

func (e *ErrorUnsupported) Error() string <span class="cov0" title="0">{ return e.err.Error() }</span>

type ScanReportParser interface {
        Parse(string) (*unversioned.UpdateManifest, error)
}

func TryParseScanReport(file, scanner string) (*unversioned.UpdateManifest, error) <span class="cov10" title="4">{
        if scanner == "trivy" </span><span class="cov5" title="2">{
                return defaultParseScanReport(file)
        }</span>
        <span class="cov5" title="2">return customParseScanReport(file, scanner)</span>
}

func customParseScanReport(file, scanner string) (*unversioned.UpdateManifest, error) <span class="cov5" title="2">{
        var scannerOutput []byte
        var err error

        if scanner != "native" </span><span class="cov5" title="2">{
                // Execute the plugin binary
                cmd := "copa-" + scanner
                scannerCommand := exec.Command(cmd, file)
                // Capture the output
                scannerOutput, err = scannerCommand.CombinedOutput()
                if err != nil </span><span class="cov5" title="2">{
                        return nil, fmt.Errorf("error running scanner %s: %w", scanner, err)
                }</span>
        } else<span class="cov0" title="0"> {
                // Read the file directly if they are in v1alpha1 format
                scannerOutput, err = os.ReadFile(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error reading file %s: %w", file, err)
                }</span>
        }

        <span class="cov0" title="0">var m map[string]interface{}
        if err := json.Unmarshal(scannerOutput, &amp;m); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error parsing scanner output: %w", err)
        }</span>

        // Convert the output to an unversioned UpdateManifest struct
        <span class="cov0" title="0">updateManifest, err := convertToUnversionedAPI(scannerOutput, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return updateManifest, nil</span>
}

func defaultParseScanReport(file string) (*unversioned.UpdateManifest, error) <span class="cov5" title="2">{
        allParsers := []ScanReportParser{
                &amp;TrivyParser{},
        }
        for _, parser := range allParsers </span><span class="cov5" title="2">{
                manifest, err := parser.Parse(file)
                if err == nil </span><span class="cov1" title="1">{
                        return manifest, nil
                }</span> else<span class="cov1" title="1"> if _, ok := err.(*ErrorUnsupported); ok </span><span class="cov1" title="1">{
                        continue</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov1" title="1">return nil, fmt.Errorf("%s is not a supported scan report format", file)</span>
}

func convertToUnversionedAPI(scannerOutput []byte, m map[string]interface{}) (*unversioned.UpdateManifest, error) <span class="cov0" title="0">{
        switch v := m["apiVersion"].(type) </span>{
        case string:<span class="cov0" title="0">
                if v == "v1alpha1" </span><span class="cov0" title="0">{
                        um, err := v1alpha1.ConvertV1alpha1UpdateManifestToUnversionedUpdateManifest(scannerOutput)
                        return um, err
                }</span>
                <span class="cov0" title="0">return nil, &amp;ErrorUnsupported{fmt.Errorf("unsupported apiVersion: %s", v)}</span>
        default:<span class="cov0" title="0">
                return nil, &amp;ErrorUnsupported{fmt.Errorf("unsupported apiVersion type: %v", v)}</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package report

import (
        "encoding/json"
        "errors"
        "os"

        trivyTypes "github.com/aquasecurity/trivy/pkg/types"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
)

type TrivyParser struct{}

func parseTrivyReport(file string) (*trivyTypes.Report, error) <span class="cov10" title="4">{
        data, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="4">var msr trivyTypes.Report
        if err = json.Unmarshal(data, &amp;msr); err != nil </span><span class="cov5" title="2">{
                return nil, &amp;ErrorUnsupported{err}
        }</span>
        <span class="cov5" title="2">return &amp;msr, nil</span>
}

func NewTrivyParser() *TrivyParser <span class="cov0" title="0">{
        return &amp;TrivyParser{}
}</span>

func (t *TrivyParser) Parse(file string) (*unversioned.UpdateManifest, error) <span class="cov5" title="2">{
        report, err := parseTrivyReport(file)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Precondition check
        <span class="cov1" title="1">result := trivyTypes.Result{}
        for i := range report.Results </span><span class="cov1" title="1">{
                r := &amp;report.Results[i]
                if r.Class == trivyTypes.ClassOSPkg </span><span class="cov1" title="1">{
                        if result.Class != "" </span><span class="cov0" title="0">{
                                return nil, errors.New("unexpected multiple results for os-pkgs")
                        }</span>
                        <span class="cov1" title="1">result = *r</span>
                }
        }
        <span class="cov1" title="1">if result.Class == "" </span><span class="cov0" title="0">{
                return nil, errors.New("no scanning results for os-pkgs found")
        }</span>

        <span class="cov1" title="1">updates := unversioned.UpdateManifest{
                Metadata: unversioned.Metadata{
                        OS: unversioned.OS{
                                Type:    string(report.Metadata.OS.Family),
                                Version: report.Metadata.OS.Name,
                        },
                        Config: unversioned.Config{
                                Arch:    report.Metadata.ImageConfig.Architecture,
                                Variant: report.Metadata.ImageConfig.Variant,
                        },
                },
        }

        for i := range result.Vulnerabilities </span><span class="cov1" title="1">{
                vuln := &amp;result.Vulnerabilities[i]
                if vuln.FixedVersion != "" </span><span class="cov1" title="1">{
                        updates.Updates = append(updates.Updates, unversioned.UpdatePackage{
                                Name:             vuln.PkgName,
                                InstalledVersion: vuln.InstalledVersion,
                                FixedVersion:     vuln.FixedVersion,
                                VulnerabilityID:  vuln.VulnerabilityID,
                        })
                }</span>
        }

        <span class="cov1" title="1">return &amp;updates, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package testutils

import (
        "log"
        "os"
        "path/filepath"
)

func CreateTempFileWithContent(dir string, dbType string) <span class="cov10" title="2">{
        path := filepath.Join(dir, dbType)
        file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov10" title="2">_, err = file.WriteString("test")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package v1alpha1

import (
        "encoding/json"
        "fmt"

        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
)

func ConvertV1alpha1UpdateManifestToUnversionedUpdateManifest(scannerOutput []byte) (*unversioned.UpdateManifest, error) <span class="cov10" title="3">{
        var um unversioned.UpdateManifest

        if err := json.Unmarshal(scannerOutput, &amp;um); err != nil </span><span class="cov6" title="2">{
                return nil, fmt.Errorf("error parsing scanner output: %w", err)
        }</span>

        <span class="cov1" title="1">return &amp;um, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        log "github.com/sirupsen/logrus"
)

type EOLProductInfo struct {
        IsEOL        bool   `json:"isEol"`
        EOLDate      string `json:"eolFrom"`
        IsMaintained bool   `json:"isMaintained"`
}

type EOLAPIResponse struct {
        SchemaVersion string         `json:"schema_version"`
        GeneratedAt   string         `json:"generated_at"`
        Result        EOLProductInfo `json:"result"`
}

var (
        apiBaseURL = "https://endoflife.date/api/v1/products"
        httpClient = &amp;http.Client{Timeout: 10 * time.Second}
)

func isNumericPrefix(s string) bool <span class="cov8" title="33">{
        if s == "" </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="32">return s[0] &gt;= '0' &amp;&amp; s[0] &lt;= '9'</span>
}

func normalizeOSIdentifier(osType, osVersion string) (apiProduct string, apiVersion string) <span class="cov10" title="52">{
        apiProduct = strings.ToLower(osType)
        apiVersion = strings.ToLower(osVersion)

        switch apiProduct </span>{
        case "debian":<span class="cov8" title="26">
                if !isNumericPrefix(apiVersion) </span><span class="cov8" title="23">{
                        switch apiVersion </span>{
                        case "buzz", "rex", "bo":<span class="cov3" title="3">
                                apiVersion = "1"</span>
                        case "hamm", "slink", "potato":<span class="cov3" title="3">
                                apiVersion = "2"</span>
                        case "woody", "sarge":<span class="cov2" title="2">
                                apiVersion = "3"</span>
                        case "etch":<span class="cov1" title="1">
                                apiVersion = "4"</span>
                        case "lenny":<span class="cov1" title="1">
                                apiVersion = "5"</span>
                        case "squeeze":<span class="cov1" title="1">
                                apiVersion = "6"</span>
                        case "wheezy":<span class="cov1" title="1">
                                apiVersion = "7"</span>
                        case "jessie":<span class="cov1" title="1">
                                apiVersion = "8"</span>
                        case "stretch":<span class="cov4" title="4">
                                apiVersion = "9"</span>
                        case "buster":<span class="cov1" title="1">
                                apiVersion = "10"</span>
                        case "bullseye":<span class="cov1" title="1">
                                apiVersion = "11"</span>
                        case "bookworm":<span class="cov1" title="1">
                                apiVersion = "12"</span>
                        case "trixie":<span class="cov1" title="1">
                                apiVersion = "13"</span>
                        case "forky":<span class="cov1" title="1">
                                apiVersion = "14"</span>
                        default:<span class="cov1" title="1">
                                log.Debugf("EOL Check: Unmapped Debian codename '%s'. Using as is for API path.", osVersion)</span>
                        }
                } else<span class="cov3" title="3"> {
                        parts := strings.Split(apiVersion, ".")
                        if len(parts) &gt; 0 </span><span class="cov3" title="3">{
                                apiVersion = parts[0]
                        }</span>
                }
        case "ubuntu":<span class="cov5" title="8">
                apiVersion = strings.TrimSpace(strings.ToLower(strings.ReplaceAll(apiVersion, "lts", "")))
                parts := strings.Split(apiVersion, ".")
                if len(parts) &gt;= 2 </span><span class="cov5" title="7">{
                        apiVersion = parts[0] + "." + parts[1]
                }</span>
        case "alpine":<span class="cov4" title="4">
                parts := strings.Split(apiVersion, ".")
                if len(parts) &gt;= 2 </span><span class="cov3" title="3">{
                        apiVersion = parts[0] + "." + parts[1]
                }</span>
        case "centos", "rhel", "rocky", "alma":<span class="cov4" title="4">
                parts := strings.Split(apiVersion, ".")
                if len(parts) &gt; 0 </span><span class="cov4" title="4">{
                        apiVersion = parts[0]
                }</span>
        case "amazon":<span class="cov2" title="2">
                apiProduct = "amazon-linux"</span>
        case "mariner", "cbl-mariner":<span class="cov4" title="4">
                apiProduct = "cbl-mariner"
                parts := strings.Split(apiVersion, ".")
                if len(parts) &gt; 0 </span><span class="cov4" title="4">{
                        apiVersion = parts[0]
                }</span>
        case "azurelinux":<span class="cov2" title="2">
                apiProduct = "azure-linux"
                parts := strings.Split(apiVersion, ".")
                if len(parts) &gt; 0 </span><span class="cov2" title="2">{
                        apiVersion = parts[0]
                }</span>
        default:<span class="cov2" title="2">
                log.Debugf("EOL Check: OS type '%s' has no specific normalization rules. Using product='%s', version_segment='%s' for API path.", osType, apiProduct, apiVersion)</span>
        }
        <span class="cov10" title="52">return apiProduct, apiVersion</span>
}

func CheckEOSL(osType, osVersion string) (bool, string, error) <span class="cov4" title="4">{
        if osType == "" || osVersion == "" </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("internal error: OS type and version must be provided for EOL check")
        }</span>

        <span class="cov4" title="4">apiProduct, apiVersion := normalizeOSIdentifier(osType, osVersion)
        if apiProduct == "" || apiVersion == "" </span><span class="cov0" title="0">{
                log.Warnf("Could not determine valid API Product and Version for OS '%s %s'. Skipping EOL check.", osType, osVersion)
                return false, "Normalization Failed", nil
        }</span>

        <span class="cov4" title="4">url := fmt.Sprintf("%s/%s/releases/%s", apiBaseURL, apiProduct, apiVersion)
        log.Debugf("EOL Check: Querying URL: %s", url)

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("failed to create EOL API request for %s/%s: %w", apiProduct, apiVersion, err)
        }</span>
        <span class="cov4" title="4">req.Header.Set("User-Agent", "copacetic")

        resp, err := httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("failed to call EOL API for %s/%s: %w", apiProduct, apiVersion, err)
        }</span>
        <span class="cov4" title="4">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov1" title="1">{
                log.Warnf("EOL Check: OS/Version %s/%s not found in the database (404).", apiProduct, apiVersion)
                return false, "Not in EOL DB", nil
        }</span>

        <span class="cov3" title="3">if resp.StatusCode == http.StatusTooManyRequests </span><span class="cov1" title="1">{
                log.Warnf("EOL Check: Rate limited by API for %s/%s (429).", apiProduct, apiVersion)
                return false, "API Rate Limited", fmt.Errorf("rate limited by EOL API")
        }</span>

        <span class="cov2" title="2">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                return false, "", fmt.Errorf("EOL API for %s/%s returned non-OK status: %d - %s", apiProduct, apiVersion, resp.StatusCode, string(bodyBytes))
        }</span>

        <span class="cov2" title="2">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", fmt.Errorf("failed to read EOL API response body for %s/%s: %w", apiProduct, apiVersion, err)
        }</span>

        <span class="cov2" title="2">var apiResp EOLAPIResponse
        if err := json.Unmarshal(body, &amp;apiResp); err != nil </span><span class="cov0" title="0">{
                log.Debugf("EOL Check: Failed to unmarshal API response for %s/%s. Body: %s. Error: %v", apiProduct, apiVersion, string(body), err)
                return false, "", fmt.Errorf("failed to unmarshal EOL API response for %s/%s: %w", apiProduct, apiVersion, err)
        }</span>
        <span class="cov2" title="2">releaseData := apiResp.Result

        log.Debugf("EOL: API Response for %s/%s - IsEOL: %t, EOLDate: '%s', IsMaintained: %t",
                apiProduct, apiVersion, releaseData.IsEOL, releaseData.EOLDate, releaseData.IsMaintained)

        isEffectivelyEOL := releaseData.IsEOL || !releaseData.IsMaintained
        displayEOLDate := releaseData.EOLDate
        if displayEOLDate == "" || strings.EqualFold(displayEOLDate, "null") </span><span class="cov0" title="0">{
                displayEOLDate = "Unknown"
        }</span>

        <span class="cov2" title="2">return isEffectivelyEOL, displayEOLDate, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package utils

import (
        "bufio"
        "io"

        log "github.com/sirupsen/logrus"
)

func LogPipe(pipe io.ReadCloser, level log.Level) <span class="cov8" title="1">{
        defer pipe.Close()
        scanner := bufio.NewScanner(pipe)
        for scanner.Scan() </span><span class="cov8" title="1">{
                log.StandardLogger().Log(level, scanner.Text())
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package utils

import (
        "context"
        "encoding/json"
        "errors"
        "os/exec"

        dockerClient "github.com/docker/docker/client"
        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/project-copacetic/copacetic/pkg/imageloader"
        log "github.com/sirupsen/logrus"
)

// For testing.
var (
        remoteGet = remote.Get
        newClient = func() (dockerClient.APIClient, error) <span class="cov0" title="0">{
                return dockerClient.NewClientWithOpts(
                        dockerClient.FromEnv,
                        dockerClient.WithAPIVersionNegotiation(),
                )
        }</span>
)

// GetMediaType returns the manifest’s media type for an image reference
// It prefers a local inspection and falls back to a registry lookup.
func GetMediaType(imageRef, runtime string) (string, error) <span class="cov5" title="2">{
        // Check if the image is local first using the appropriate runtime
        var mt string
        var err error

        switch runtime </span>{
        case imageloader.Podman:<span class="cov0" title="0">
                mt, err = podmanMediaType(imageRef)</span>
        default:<span class="cov5" title="2">
                // Default to Docker
                mt, err = localMediaType(imageRef)</span>
        }

        <span class="cov5" title="2">if err == nil &amp;&amp; mt != "" </span><span class="cov1" title="1">{
                log.Debugf("local media type found for %s using %s: %s", imageRef, runtime, mt)
                return mt, nil
        }</span>
        <span class="cov1" title="1">log.Debugf("local media type not found for %s using %s: %v", imageRef, runtime, err)

        // If the image is not local, use the remote media type
        return remoteMediaType(imageRef)</span>
}

func localMediaType(imageRef string) (string, error) <span class="cov10" title="4">{
        cli, err := newClient()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="4">defer cli.Close()

        distInspect, err := cli.ImageInspect(context.Background(), imageRef)
        if err != nil </span><span class="cov5" title="2">{
                return "", err
        }</span>
        <span class="cov5" title="2">if distInspect.Descriptor == nil </span><span class="cov0" title="0">{
                return "", errors.New("descriptor is nil")
        }</span>
        <span class="cov5" title="2">return distInspect.Descriptor.MediaType, nil</span>
}

// podmanMediaType tries to get the manifest's media type using podman CLI.
func podmanMediaType(imageRef string) (string, error) <span class="cov0" title="0">{
        // Check if podman is available
        if _, err := exec.LookPath("podman"); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Run podman inspect to get image metadata
        <span class="cov0" title="0">cmd := exec.Command("podman", "inspect", "--type", "image", imageRef)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Parse the JSON output
        <span class="cov0" title="0">var inspectResults []map[string]interface{}
        if err := json.Unmarshal(output, &amp;inspectResults); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if len(inspectResults) == 0 </span><span class="cov0" title="0">{
                return "", errors.New("no inspect results")
        }</span>

        <span class="cov0" title="0">result := inspectResults[0]

        // Try to get MediaType from the result
        if mt, ok := result["MediaType"].(string); ok &amp;&amp; mt != "" </span><span class="cov0" title="0">{
                return mt, nil
        }</span>

        // Try to get it from ManifestType (some versions of podman use this)
        <span class="cov0" title="0">if mt, ok := result["ManifestType"].(string); ok &amp;&amp; mt != "" </span><span class="cov0" title="0">{
                return mt, nil
        }</span>

        <span class="cov0" title="0">return "", nil</span>
}

func remoteMediaType(imageRef string) (string, error) <span class="cov8" title="3">{
        ref, err := name.ParseReference(imageRef)
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("failed to parse reference %s: %v", imageRef, err)
                return "", err
        }</span>
        <span class="cov8" title="3">desc, err := remoteGet(ref, remote.WithAuthFromKeychain(authn.DefaultKeychain))
        if err != nil </span><span class="cov1" title="1">{
                log.Debugf("failed to get remote media type for %s: %v", imageRef, err)
                return "", err
        }</span>
        <span class="cov5" title="2">log.Debugf("remote media type found for %s: %s", imageRef, desc.MediaType)
        return string(desc.MediaType), nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package utils

import (
        "context"
        "encoding/json"
        "fmt"
        "io/fs"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/containerd/errdefs"
        "github.com/containerd/platforms"
        "github.com/google/go-containerregistry/pkg/authn"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/google/go-containerregistry/pkg/v1/types"
        "github.com/moby/buildkit/client/llb"
        "github.com/opencontainers/go-digest"
        ocispec "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/project-copacetic/copacetic/pkg/imageloader"
        log "github.com/sirupsen/logrus"
)

func EnsurePath(path string, perm fs.FileMode) (bool, error) <span class="cov8" title="6">{
        createdPath := false
        st, err := os.Stat(path)
        if err != nil &amp;&amp; os.IsNotExist(err) </span><span class="cov1" title="1">{
                err = os.MkdirAll(path, perm)
                createdPath = (err == nil)
        }</span> else<span class="cov7" title="5"> {
                if !st.IsDir() </span><span class="cov1" title="1">{
                        return false, fs.ErrExist
                }</span>
                <span class="cov7" title="4">if st.Mode().Perm() != perm </span><span class="cov5" title="3">{
                        return false, fs.ErrPermission
                }</span>
        }
        <span class="cov4" title="2">return createdPath, err</span>
}

func IsNonEmptyFile(dir, file string) bool <span class="cov8" title="6">{
        p := filepath.Join(dir, file)
        info, err := os.Stat(p)
        if os.IsNotExist(err) </span><span class="cov4" title="2">{
                return false
        }</span>
        <span class="cov7" title="4">return !info.IsDir() &amp;&amp; info.Size() &gt; 0</span>
}

func getEnvAny(names ...string) string <span class="cov10" title="8">{
        for _, n := range names </span><span class="cov10" title="8">{
                if val := os.Getenv(n); val != "" </span><span class="cov7" title="4">{
                        return val
                }</span>
        }
        <span class="cov7" title="4">return ""</span>
}

func GetProxy() llb.ProxyEnv <span class="cov4" title="2">{
        proxy := llb.ProxyEnv{
                HTTPProxy:  getEnvAny("HTTP_PROXY"),
                HTTPSProxy: getEnvAny("HTTPS_PROXY"),
                NoProxy:    getEnvAny("NO_PROXY"),
                AllProxy:   getEnvAny("HTTP_PROXY"),
        }
        return proxy
}</span>

// localImageDescriptor tries to get the OCI image descriptor using the local Docker client.
func localImageDescriptor(ctx context.Context, imageRef string) (*ocispec.Descriptor, error) <span class="cov0" title="0">{
        cli, err := newClient()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create docker client: %w", err)
        }</span>
        <span class="cov0" title="0">defer cli.Close()

        distInspect, err := cli.ImageInspect(ctx, imageRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return distInspect.Descriptor, nil</span>
}

// podmanImageDescriptor tries to get the OCI image descriptor using podman CLI.
func podmanImageDescriptor(ctx context.Context, imageRef string) (*ocispec.Descriptor, error) <span class="cov0" title="0">{
        // Check if podman is available
        if _, err := exec.LookPath("podman"); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("podman not found in PATH: %w", err)
        }</span>

        // Run podman inspect to get image metadata
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "podman", "inspect", "--type", "image", imageRef)
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                if exitErr, ok := err.(*exec.ExitError); ok </span><span class="cov0" title="0">{
                        // Check if it's a "not found" error
                        stderr := string(exitErr.Stderr)
                        if strings.Contains(stderr, "no such image") || strings.Contains(stderr, "not found") </span><span class="cov0" title="0">{
                                return nil, errdefs.ErrNotFound
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("podman inspect failed: %w", err)</span>
        }

        // Parse the JSON output
        <span class="cov0" title="0">var inspectResults []map[string]interface{}
        if err := json.Unmarshal(output, &amp;inspectResults); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse podman inspect output: %w", err)
        }</span>

        <span class="cov0" title="0">if len(inspectResults) == 0 </span><span class="cov0" title="0">{
                return nil, errdefs.ErrNotFound
        }</span>

        <span class="cov0" title="0">result := inspectResults[0]

        // Extract relevant fields to construct the descriptor
        digestStr, _ := result["Digest"].(string)
        if digestStr == "" </span><span class="cov0" title="0">{
                digestStr, _ = result["Id"].(string)
                if digestStr != "" &amp;&amp; !strings.HasPrefix(digestStr, "sha256:") </span><span class="cov0" title="0">{
                        digestStr = "sha256:" + digestStr
                }</span>
        }

        <span class="cov0" title="0">size := int64(0)
        if sizeVal, ok := result["Size"].(float64); ok </span><span class="cov0" title="0">{
                size = int64(sizeVal)
        }</span>

        // Get architecture and OS
        <span class="cov0" title="0">architecture := "amd64"
        os := "linux"
        if archVal, ok := result["Architecture"].(string); ok </span><span class="cov0" title="0">{
                architecture = archVal
        }</span>
        <span class="cov0" title="0">if osVal, ok := result["Os"].(string); ok </span><span class="cov0" title="0">{
                os = osVal
        }</span>

        // Construct the descriptor
        <span class="cov0" title="0">desc := &amp;ocispec.Descriptor{
                MediaType: ocispec.MediaTypeImageManifest,
                Digest:    digest.Digest(digestStr),
                Size:      size,
                Platform: &amp;ocispec.Platform{
                        Architecture: architecture,
                        OS:           os,
                },
        }

        return desc, nil</span>
}

// remoteImageDescriptor tries to get the OCI image descriptor from a remote registry.
func remoteImageDescriptor(imageRef string) (*ocispec.Descriptor, error) <span class="cov0" title="0">{
        ref, err := name.ParseReference(imageRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse image reference '%s': %w", imageRef, err)
        }</span>

        <span class="cov0" title="0">ggcrDesc, err := remoteGet(ref, remote.WithAuthFromKeychain(authn.DefaultKeychain))
        if err != nil </span><span class="cov0" title="0">{
                log.Debugf("failed to get remote descriptor for %s: %v", imageRef, err)
                return nil, fmt.Errorf("failed to get remote descriptor for '%s': %w", imageRef, err)
        }</span>

        <span class="cov0" title="0">ociDesc := &amp;ocispec.Descriptor{
                MediaType:    string(ggcrDesc.MediaType),
                Size:         ggcrDesc.Size,
                Digest:       digest.Digest(ggcrDesc.Digest.String()),
                URLs:         ggcrDesc.URLs,
                Annotations:  ggcrDesc.Annotations,
                Data:         ggcrDesc.Data,
                ArtifactType: ggcrDesc.ArtifactType,
        }

        if ggcrDesc.Platform != nil </span><span class="cov0" title="0">{
                ociDesc.Platform = &amp;ocispec.Platform{
                        Architecture: ggcrDesc.Platform.Architecture,
                        OS:           ggcrDesc.Platform.OS,
                        OSVersion:    ggcrDesc.Platform.OSVersion,
                        OSFeatures:   ggcrDesc.Platform.OSFeatures,
                        Variant:      ggcrDesc.Platform.Variant,
                }
        }</span>
        <span class="cov0" title="0">return ociDesc, nil</span>
}

// GetImageDescriptor retrieves the image descriptor for a given image reference using the specified runtime.
// It first tries to inspect the image using the specified runtime client (local).
// If the image is not found locally or a local error occurs, it tries to get the image descriptor from the remote registry.
// runtime should be imageloader.Docker or imageloader.Podman.
func GetImageDescriptor(ctx context.Context, imageRef, runtime string) (*ocispec.Descriptor, error) <span class="cov0" title="0">{
        log.Debugf("Attempting to get local image descriptor for %s using runtime %s", imageRef, runtime)

        var localDesc *ocispec.Descriptor
        var localErr error

        switch runtime </span>{
        case imageloader.Podman:<span class="cov0" title="0">
                localDesc, localErr = podmanImageDescriptor(ctx, imageRef)</span>
        default:<span class="cov0" title="0">
                // Default to Docker
                localDesc, localErr = localImageDescriptor(ctx, imageRef)</span>
        }

        <span class="cov0" title="0">if localErr == nil </span><span class="cov0" title="0">{
                log.Infof("found local image descriptor for %s via %s", imageRef, runtime)
                return localDesc, nil
        }</span>

        <span class="cov0" title="0">isNotFoundError := errdefs.IsNotFound(localErr)
        if isNotFoundError </span><span class="cov0" title="0">{
                log.Debugf("image %s not found locally in %s (error: %v), trying remote.", imageRef, runtime, localErr)
        }</span> else<span class="cov0" title="0"> {
                log.Warnf("local descriptor lookup for %s failed in %s (error: %v), trying remote.", imageRef, runtime, localErr)
        }</span>

        <span class="cov0" title="0">log.Debugf("attempting to get remote image descriptor for %s", imageRef)
        remoteDesc, remoteErr := remoteImageDescriptor(imageRef)
        if remoteErr != nil </span><span class="cov0" title="0">{
                log.Errorf("failed to get remote image descriptor for %s: %v", imageRef, remoteErr)
                if isNotFoundError </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("image '%s' not found locally and remote lookup failed: %w", imageRef, remoteErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("local lookup for '%s' failed (error: %v) and remote lookup also failed (error: %v)", imageRef, localErr, remoteErr)</span>
        }

        <span class="cov0" title="0">log.Infof("found remote image descriptor for %s", imageRef)
        return remoteDesc, nil</span>
}

// GetIndexManifestAnnotations retrieves annotations from an image index manifest.
// This is specifically for multi-platform images to get the index-level annotations.
func GetIndexManifestAnnotations(_ context.Context, imageRef string) (map[string]string, error) <span class="cov0" title="0">{
        ref, err := name.ParseReference(imageRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse image reference '%s': %w", imageRef, err)
        }</span>

        // First check if this is an index
        <span class="cov0" title="0">desc, err := remoteGet(ref, remote.WithAuthFromKeychain(authn.DefaultKeychain))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get descriptor for '%s': %w", imageRef, err)
        }</span>

        // Check if this is an index manifest
        <span class="cov0" title="0">if desc.MediaType != types.OCIImageIndex &amp;&amp; desc.MediaType != types.DockerManifestList </span><span class="cov0" title="0">{
                log.Debugf("Image %s is not a multi-platform image (media type: %s)", imageRef, desc.MediaType)
                // For single platform images, return the descriptor annotations
                return desc.Annotations, nil
        }</span>

        // Fetch the actual index
        <span class="cov0" title="0">idx, err := desc.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get image index for '%s': %w", imageRef, err)
        }</span>

        // Get the index manifest
        <span class="cov0" title="0">indexManifest, err := idx.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get index manifest for '%s': %w", imageRef, err)
        }</span>

        <span class="cov0" title="0">return indexManifest.Annotations, nil</span>
}

// GetPlatformManifestAnnotations retrieves manifest-level annotations for a specific platform
// from an image index manifest.
func GetPlatformManifestAnnotations(_ context.Context, imageRef string, targetPlatform *ocispec.Platform) (map[string]string, error) <span class="cov0" title="0">{
        ref, err := name.ParseReference(imageRef)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse image reference '%s': %w", imageRef, err)
        }</span>

        // First check if this is an index
        <span class="cov0" title="0">desc, err := remoteGet(ref, remote.WithAuthFromKeychain(authn.DefaultKeychain))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get descriptor for '%s': %w", imageRef, err)
        }</span>

        // Check if this is an index manifest
        <span class="cov0" title="0">if desc.MediaType != types.OCIImageIndex &amp;&amp; desc.MediaType != types.DockerManifestList </span><span class="cov0" title="0">{
                log.Debugf("Image %s is not a multi-platform image (media type: %s)", imageRef, desc.MediaType)
                // For single platform images, return empty annotations
                return nil, nil
        }</span>

        // Fetch the actual index
        <span class="cov0" title="0">idx, err := desc.ImageIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get image index for '%s': %w", imageRef, err)
        }</span>

        // Get the index manifest
        <span class="cov0" title="0">indexManifest, err := idx.IndexManifest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get index manifest for '%s': %w", imageRef, err)
        }</span>

        // Find the matching platform in the manifest list
        <span class="cov0" title="0">for i := range indexManifest.Manifests </span><span class="cov0" title="0">{
                manifest := &amp;indexManifest.Manifests[i]
                if manifest.Platform == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Compare platforms (normalize variants for comparison)
                <span class="cov0" title="0">manifestPlatform := ocispec.Platform{
                        OS:           manifest.Platform.OS,
                        Architecture: manifest.Platform.Architecture,
                        Variant:      manifest.Platform.Variant,
                }

                // Use containerd's OnlyStrict matcher which handles variant normalization
                // including arm64/v8 matching arm64 (empty variant)
                matcher := platforms.OnlyStrict(*targetPlatform)
                if matcher.Match(manifestPlatform) </span><span class="cov0" title="0">{
                        // Return the manifest-level annotations for this platform
                        if manifest.Annotations != nil </span><span class="cov0" title="0">{
                                return manifest.Annotations, nil
                        }</span>
                        <span class="cov0" title="0">return map[string]string{}, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("platform %s/%s/%s not found in image index", targetPlatform.OS, targetPlatform.Architecture, targetPlatform.Variant)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package vex

import (
        "bytes"
        "os"
        "time"

        "github.com/openvex/go-vex/pkg/vex"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
)

// used for testing mock time and id.
var (
        now = time.Now
        v   = &amp;vex.VEX{
                Metadata: vex.Metadata{
                        Context: vex.Context,
                        Author:  "Project Copacetic",
                        Tooling: "Project Copacetic",
                        Version: 1,
                },
        }
        id func() (string, error) = v.GenerateCanonicalID
)

type OpenVex struct{}

func (o *OpenVex) CreateVEXDocument(
        updates *unversioned.UpdateManifest,
        patchedImageName string,
        pkgType string,
) (string, error) <span class="cov10" title="3">{
        t := now()
        doc := v
        doc.Timestamp = &amp;t

        // set author from environment variable if it exists
        author := os.Getenv("COPA_VEX_AUTHOR")
        if author != "" </span><span class="cov6" title="2">{
                doc.Author = author
        }</span>

        <span class="cov10" title="3">id, err := id()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov10" title="3">doc.ID = id

        imageProduct := vex.Product{
                Component: vex.Component{
                        ID: "pkg:oci/" + patchedImageName,
                },
        }

        for _, u := range updates.Updates </span><span class="cov10" title="3">{
                subComponent := vex.Subcomponent{
                        Component: vex.Component{
                                // syntax is "pkg:&lt;pkgType&gt;/&lt;osType&gt;/&lt;packageName&gt;@&lt;installedVersion&gt;?arch=&lt;arch&gt;"
                                ID: "pkg:" + pkgType + "/" + updates.Metadata.OS.Type + "/" + u.Name + "@" + u.FixedVersion + "?arch=" + updates.Metadata.Config.Arch,
                        },
                }

                // if vulnerable id already exists, append to existing statement
                found := false
                for i := range doc.Statements </span><span class="cov6" title="2">{
                        if doc.Statements[i].Vulnerability.ID == u.VulnerabilityID </span><span class="cov1" title="1">{
                                found = true
                                doc.Statements[i].Products[0].Subcomponents = append(doc.Statements[i].Products[0].Subcomponents, subComponent)
                        }</span>
                }
                <span class="cov10" title="3">if found </span><span class="cov1" title="1">{
                        continue</span>
                }

                // otherwise, create new statement
                <span class="cov6" title="2">imageProduct.Subcomponents = []vex.Subcomponent{subComponent}
                doc.Statements = append(doc.Statements, vex.Statement{
                        Vulnerability: vex.Vulnerability{
                                ID: u.VulnerabilityID,
                        },
                        Products: []vex.Product{imageProduct},
                        Status:   "fixed",
                })</span>
        }

        <span class="cov10" title="3">var buf bytes.Buffer
        err = doc.ToJSON(&amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov10" title="3">return buf.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package vex

import (
        "fmt"
        "os"

        "github.com/project-copacetic/copacetic/pkg/pkgmgr"
        "github.com/project-copacetic/copacetic/pkg/types/unversioned"
)

type Vex interface {
        CreateVEXDocument(updates *unversioned.UpdateManifest, patchedImageName string, pkgmgr pkgmgr.PackageManager) (string, error)
}

func TryOutputVexDocument(updates *unversioned.UpdateManifest, pkgType, patchedImageName, format, file string) error <span class="cov10" title="2">{
        var doc string
        var err error

        switch format </span>{
        case "openvex":<span class="cov1" title="1">
                ov := &amp;OpenVex{}
                doc, err = ov.CreateVEXDocument(updates, patchedImageName, pkgType)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov1" title="1">
                return fmt.Errorf("unsupported output format %s specified", format)</span>
        }
        <span class="cov1" title="1">return os.WriteFile(file, []byte(doc), 0o600)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7885],{2497:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"app-level-patching","title":"App-Level Patching","description":"App-level patching is an experimental feature that requires setting the COPA_EXPERIMENTAL=1 environment variable to enable. This feature is under active development, and future releases may introduce breaking changes. Feedback is welcome!","source":"@site/docs/app-level-patching.md","sourceDirName":".","slug":"/app-level-patching","permalink":"/copacetic/website/next/app-level-patching","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"App-Level Patching"},"sidebar":"sidebar","previous":{"title":"FAQ","permalink":"/copacetic/website/next/faq"},"next":{"title":"Github Action","permalink":"/copacetic/website/next/github-action"}}');var t=i(4848),s=i(8453);const l={title:"App-Level Patching"},r=void 0,o={},c=[{value:"Overview",id:"overview",level:2},{value:"Package Type Filtering",id:"package-type-filtering",level:2},{value:"Package Type Options",id:"package-type-options",level:3},{value:"Patch Level Control",id:"patch-level-control",level:2},{value:"Patch Level Behavior",id:"patch-level-behavior",level:3},{value:"<code>patch</code> Level (Recommended)",id:"patch-level-recommended",level:4},{value:"<code>minor</code> Level",id:"minor-level",level:4},{value:"<code>major</code> Level",id:"major-level",level:4},{value:"Special Package Handling",id:"special-package-handling",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Ignoring Errors",id:"ignoring-errors",level:3},{value:"Limitations",id:"limitations",level:2},{value:"Python",id:"python",level:3},{value:"Dependency Resolution",id:"dependency-resolution",level:4},{value:"Python Version Compatibility",id:"python-version-compatibility",level:4},{value:"Testing and Validation",id:"testing-and-validation",level:4},{value:"Non Existent Versions",id:"non-existent-versions",level:4},{value:"Virtual Environment and Package Manager Support",id:"virtual-environment-and-package-manager-support",level:4},{value:"Replacing PyPI",id:"replacing-pypi",level:4}];function p(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.admonition,{title:"Experimental Feature",type:"warning",children:(0,t.jsxs)(n.p,{children:["App-level patching is an experimental feature that requires setting the ",(0,t.jsx)(n.code,{children:"COPA_EXPERIMENTAL=1"})," environment variable to enable. This feature is under active development, and future releases may introduce breaking changes. Feedback is welcome!"]})}),"\n",(0,t.jsx)(n.p,{children:"Copa supports patching application-level dependencies, such as Python packages, in addition to operating system packages. This feature allows you to update vulnerable libraries and packages in various programming language ecosystems."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"App-level patching works by scanning and updating application dependencies found in your container images. Unlike OS-level patching which updates system packages, app-level patching focuses on:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Python packages (",(0,t.jsx)(n.code,{children:"pip"})," is the supported package manager)"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Please note that app-level patching requires scanner results that identify vulnerabilities in application libraries."}),"\n",(0,t.jsx)(n.h2,{id:"package-type-filtering",children:"Package Type Filtering"}),"\n",(0,t.jsxs)(n.p,{children:["Copa supports filtering between different types of packages using the ",(0,t.jsx)(n.code,{children:"--pkg-types"})," flag:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Patch only OS packages (default)\ncopa patch -i $IMAGE --pkg-types os ...\n\n# Patch only library/app-level packages\ncopa patch -i $IMAGE --pkg-types library ...\n\n# Patch both OS and library packages\ncopa patch -i $IMAGE --pkg-types os,library ...\n"})}),"\n",(0,t.jsx)(n.h3,{id:"package-type-options",children:"Package Type Options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"os"}),": Operating system packages (APT, YUM, APK, etc.). This is the default behavior if no ",(0,t.jsx)(n.code,{children:"--pkg-types"})," flag is specified."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"library"}),": Application-level packages (Python, Node.js, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"os,library"}),": Both types"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This filtering is particularly useful when you want to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Apply different patch policies to OS vs. application dependencies"}),"\n",(0,t.jsx)(n.li,{children:"Separate OS security updates from application updates"}),"\n",(0,t.jsx)(n.li,{children:"Reduce the scope of changes in production environments"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"patch-level-control",children:"Patch Level Control"}),"\n",(0,t.jsxs)(n.p,{children:["Copa allows you to control how aggressively application-level packages are updated based on their versioning. This is particularly useful for managing compatibility and stability in your applications. The ",(0,t.jsx)(n.code,{children:"--library-patch-level"})," flag determines the maximum version bump allowed for library updates:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Only apply patch-level updates (e.g., 2.6.0 \u2192 2.6.1)\ncopa patch -i $IMAGE --pkg-types library --library-patch-level patch ...\n\n# Allow minor version updates (e.g., 2.6.0 \u2192 2.7.0, prefer 2.6.1)\ncopa patch -i $IMAGE --pkg-types library --library-patch-level minor ...\n\n# Allow major version updates (e.g., 2.6.0 \u2192 3.0.0, prefer 2.6.1)\ncopa patch -i $IMAGE --pkg-types library --library-patch-level major ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Please note that the ",(0,t.jsx)(n.code,{children:"--library-patch-level"})," flag requires the ",(0,t.jsx)(n.code,{children:"--pkg-types library"})," option to be set. Default behavior is ",(0,t.jsx)(n.code,{children:"patch"})," level if not specified."]}),"\n",(0,t.jsx)(n.h3,{id:"patch-level-behavior",children:"Patch Level Behavior"}),"\n",(0,t.jsx)(n.p,{children:"The patch level determines the maximum version bump allowed for library updates:"}),"\n",(0,t.jsxs)(n.h4,{id:"patch-level-recommended",children:[(0,t.jsx)(n.code,{children:"patch"})," Level (Recommended)"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Allows"}),": ",(0,t.jsx)(n.code,{children:"2.6.0"})," \u2192 ",(0,t.jsx)(n.code,{children:"2.6.1"}),", ",(0,t.jsx)(n.code,{children:"2.6.2"}),", etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Blocks"}),": ",(0,t.jsx)(n.code,{children:"2.6.0"})," \u2192 ",(0,t.jsx)(n.code,{children:"2.7.0"})," or ",(0,t.jsx)(n.code,{children:"3.0.0"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use case"}),": Conservative updates, minimal risk of breaking changes"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"minor-level",children:[(0,t.jsx)(n.code,{children:"minor"})," Level"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Allows"}),": ",(0,t.jsx)(n.code,{children:"2.6.0"})," \u2192 ",(0,t.jsx)(n.code,{children:"2.6.1"})," (preferred) or ",(0,t.jsx)(n.code,{children:"2.7.0"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Blocks"}),": ",(0,t.jsx)(n.code,{children:"2.6.0"})," \u2192 ",(0,t.jsx)(n.code,{children:"3.0.0"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preference"}),": If both ",(0,t.jsx)(n.code,{children:"2.6.1"})," and ",(0,t.jsx)(n.code,{children:"2.7.0"})," are available, it will choose ",(0,t.jsx)(n.code,{children:"2.6.1"})," (patch) over ",(0,t.jsx)(n.code,{children:"2.7.0"})," (minor)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use case"}),": Moderate updates, some new features acceptable"]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"major-level",children:[(0,t.jsx)(n.code,{children:"major"})," Level"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Allows"}),": Any version update"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Preference"}),": When comma-separated versions are available, prefers Patch > Minor > Major for compatibility. When no comma-separated versions exist, picks the highest version to fix all CVEs."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Example"}),": If both ",(0,t.jsx)(n.code,{children:"2.6.1"})," and ",(0,t.jsx)(n.code,{children:"2.7.0"})," are available, it will choose ",(0,t.jsx)(n.code,{children:"2.6.1"})," for better compatibility"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use case"}),": Aggressive updates, all fixes applied regardless of compatibility risk"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Please note that ",(0,t.jsx)(n.code,{children:"copa"})," does not guarantee compatibility with all versions. The patch level only controls the maximum version bump allowed. Always test your application after patching."]})}),"\n",(0,t.jsx)(n.h3,{id:"special-package-handling",children:"Special Package Handling"}),"\n",(0,t.jsx)(n.p,{children:"Some packages have special handling due to their nature:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"certifi"}),": Always updated to the latest version regardless of patch level setting"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.p,{children:"To use app-level patching, you need to have a scanner result file that contains vulnerabilities for application-level packages. Below is an example of how to scan a Python image and then apply patches using Copa."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"export COPA_EXPERIMENTAL=1\nexport IMAGE=python:3.11.0\n\n# Scan for Python package vulnerabilities\ntrivy image --vuln-type os,library --ignore-unfixed -f json -o python-scan.json $IMAGE\n"})}),"\n",(0,t.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Apply patch-level Python package updates only\ncopa patch \\\n    -i $IMAGE \\\n    -r python-scan.json \\\n    --pkg-types os,library \\\n    --library-patch-level patch\n"})}),"\n",(0,t.jsx)(n.h3,{id:"ignoring-errors",children:"Ignoring Errors"}),"\n",(0,t.jsxs)(n.p,{children:["Sometimes, certain packages may not be compatible with the patching process or may not have available updates. In such cases, you can use the ",(0,t.jsx)(n.code,{children:"--ignore-errors"})," flag to allow Copa to continue patching other packages even if some fail. This is useful in environments where you want to apply as many updates as possible without failing the entire patching process."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Apply patch-level Python package updates, ignoring errors\ncopa patch \\\n    -i $IMAGE \\\n    -r python-scan.json \\\n    --pkg-types os,library \\\n    --library-patch-level major \\\n    --ignore-errors\n"})}),"\n",(0,t.jsx)(n.h2,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(n.p,{children:"Due to nature of app-level patching, it may not be as comprehensive as OS-level patching. Some known limitations are:"}),"\n",(0,t.jsx)(n.h3,{id:"python",children:"Python"}),"\n",(0,t.jsx)(n.h4,{id:"dependency-resolution",children:"Dependency Resolution"}),"\n",(0,t.jsx)(n.p,{children:"Copa does not perform dependency resolution for application-level packages. It applies updates based on the scanner results without checking for compatibility with other packages in the environment. This means that while Copa can update vulnerable packages, it may not resolve all dependency conflicts that arise from those updates."}),"\n",(0,t.jsx)(n.p,{children:"For example, if a package has a strict version requirement that conflicts with the updated version, you may encounter errors like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"#8 8.971 ERROR: Cannot install azure-cli and paramiko==3.4.0 because these package versions have conflicting dependencies.\n#8 8.971\n#8 8.971 The conflict is caused by:\n#8 8.971     The user requested paramiko==3.4.0\n#8 8.971     azure-cli-core 2.40.0 depends on paramiko<3.0.0 and >=2.0.8\n#8 8.971\n#8 8.971 To fix this you could try to:\n#8 8.971 1. loosen the range of package versions you've specified\n#8 8.971 2. remove package versions to allow pip attempt to solve the dependency conflict\n"})}),"\n",(0,t.jsx)(n.h4,{id:"python-version-compatibility",children:"Python Version Compatibility"}),"\n",(0,t.jsx)(n.p,{children:"Copa does not check whether the updated Python packages are compatible with the Python version in the image. For example, if you update a package that requires Python 3.12 to a version that is not compatible with Python 3.11, you may encounter runtime or dependency resolution errors."}),"\n",(0,t.jsx)(n.h4,{id:"testing-and-validation",children:"Testing and Validation"}),"\n",(0,t.jsxs)(n.p,{children:["Due to the nature of app-level patching, it is ",(0,t.jsx)(n.em,{children:"highly recommended"})," to thoroughly test your application after applying updates. Copa does not perform any automated testing or validation of the patched application, so you should ensure that your application functions correctly with the updated dependencies."]}),"\n",(0,t.jsx)(n.h4,{id:"non-existent-versions",children:"Non Existent Versions"}),"\n",(0,t.jsxs)(n.p,{children:["Trivy provides vulnerability data for Python dependencies using ",(0,t.jsx)(n.a,{href:"https://github.com/advisories",children:"GitHub Security Advisories"})," (GHSA). However, it does not check whether the patched version exists in the ",(0,t.jsx)(n.a,{href:"https://pypi.org",children:"Python Package Index"})," (PyPI). For example, ",(0,t.jsx)(n.a,{href:"https://github.com/advisories/GHSA-3749-ghw9-m3mg",children:(0,t.jsx)(n.code,{children:"GHSA-3749-ghw9-m3mg"})})," contains a vulnerability for torch package, but the patched version ",(0,t.jsx)(n.code,{children:"2.0.2.7.1-rc1"})," does not exist in PyPI at the time of this writing."]}),"\n",(0,t.jsx)(n.h4,{id:"virtual-environment-and-package-manager-support",children:"Virtual Environment and Package Manager Support"}),"\n",(0,t.jsxs)(n.p,{children:["Currently, only Python packages managed by ",(0,t.jsx)(n.code,{children:"pip"})," are supported. We have not evaluated or implemented support for virtual environments, or other Python package managers like ",(0,t.jsx)(n.code,{children:"conda"})," or ",(0,t.jsx)(n.code,{children:"poetry"})," and others. This might break compatibility with applications that use these package managers."]}),"\n",(0,t.jsx)(n.h4,{id:"replacing-pypi",children:"Replacing PyPI"}),"\n",(0,t.jsxs)(n.p,{children:["Copa does not support replacing the default ",(0,t.jsx)(n.a,{href:"https://pypi.org",children:"Python Package Index"})," (PyPI) with a custom index or mirror at this time. This means that all package updates are fetched from the official PyPI repository, which may not be suitable for all environments, especially those with strict network policies or private package registries."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var a=i(6540);const t={},s=a.createContext(t);function l(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);
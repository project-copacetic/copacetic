"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1489],{9116:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>c,toc:()=>h});var a=i(4848),n=i(8453);const s={title:"Tagging Guidelines"},o=void 0,c={id:"best-practices",title:"Tagging Guidelines",description:"There are some patterns and practices you may want to consider when using Copa to patch images. Remember that these are suggestions that may not fit into your workflow, but we think that staying as close as possible to these practices offers the best experience with Copa.",source:"@site/versioned_docs/version-v0.8.x/best-practices.md",sourceDirName:".",slug:"/best-practices",permalink:"/copacetic/website/best-practices",draft:!1,unlisted:!1,tags:[],version:"v0.8.x",frontMatter:{title:"Tagging Guidelines"},sidebar:"sidebar",previous:{title:"Quick Start",permalink:"/copacetic/website/quick-start"},next:{title:"Troubleshooting",permalink:"/copacetic/website/troubleshooting"}},r={},h=[{value:"Patch from Unmodified image",id:"patch-from-unmodified-image",level:2},{value:"Tagging",id:"tagging",level:2},{value:"Static Incremental Tags",id:"static-incremental-tags",level:3},{value:"Dynamic Tags",id:"dynamic-tags",level:3}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"There are some patterns and practices you may want to consider when using Copa to patch images. Remember that these are suggestions that may not fit into your workflow, but we think that staying as close as possible to these practices offers the best experience with Copa."}),"\n",(0,a.jsx)(t.h2,{id:"patch-from-unmodified-image",children:"Patch from Unmodified image"}),"\n",(0,a.jsxs)(t.p,{children:["When patching vulnerabilities in an image, it helps to always work from the initial unmodified image. For example, say you have an image tagged ",(0,a.jsx)(t.code,{children:"nginx:1.24.0"})," that contains a vulnerability. You run Copa to patch the image and produce a new image tagged ",(0,a.jsx)(t.code,{children:"nginx:1.24.0-1"}),". Then if another vulnerability shows up in your ",(0,a.jsx)(t.code,{children:"nginx:1.24.0-1"})," image, you should again patch from the unmodified ",(0,a.jsx)(t.code,{children:"nginx:1.24.0"})," image. This will help prevent the buildup of patch layers (",(0,a.jsx)(t.a,{href:"https://github.com/project-copacetic/copacetic/issues/389",children:"discarding subsequent patch layers"})," is a potential future enhancement)."]}),"\n",(0,a.jsx)(t.h2,{id:"tagging",children:"Tagging"}),"\n",(0,a.jsx)(t.p,{children:"There are a couple possible patterns that you could follow when tagging patched images."}),"\n",(0,a.jsx)(t.h3,{id:"static-incremental-tags",children:"Static Incremental Tags"}),"\n",(0,a.jsxs)(t.p,{children:["The first approach you could take is incrementing a number you append to the end of an image tag. For example, if you have an image tagged ",(0,a.jsx)(t.code,{children:"nginx:1.24.0"}),", following patches would be tagged as ",(0,a.jsx)(t.code,{children:"nginx:1.24.0-1"}),", ",(0,a.jsx)(t.code,{children:"nginx:1.24.0-2"}),", ",(0,a.jsx)(t.code,{children:"nginx:1.24.0-3"}),", and so on."]}),"\n",(0,a.jsx)(t.p,{children:"With this pattern you are always explicitly aware of the patch state of the image you are using. The downside is that dependabot is currently unable bump to patched images from unmodified images or bump from one patched image to the next."}),"\n",(0,a.jsx)(t.h3,{id:"dynamic-tags",children:"Dynamic Tags"}),"\n",(0,a.jsxs)(t.p,{children:["Another option is a static tag that is continually reused as new patches are applied. For example, you could have an initial unmodified image that you've tagged ",(0,a.jsx)(t.code,{children:"nginx:1.24.0-0"})," (in this case the ",(0,a.jsx)(t.code,{children:"-0"})," at the end helps identify the base unpatched image). All following patched images are then tagged as ",(0,a.jsx)(t.code,{children:"nginx:1.24.0"}),". You then know that the one tagged image always has the latest patches applied."]}),"\n",(0,a.jsxs)(t.p,{children:["This method makes it easy to continually consume the latest patched version of an image, but does contain some tradeoffs. First is that without pinning, image digests could change causing unpredictable behavior. Secondly, if an ",(0,a.jsx)(t.code,{children:"ImagePullPolicy"})," is set to ",(0,a.jsx)(t.code,{children:"IfNotPresent"}),", newly patched images would not be pulled since the tag hasn't changed."]})]})}function l(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>c});var a=i(6540);const n={},s=a.createContext(n);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[864],{5303:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>r});const i=JSON.parse('{"id":"best-practices","title":"Tagging Guidelines","description":"There are some patterns and practices you may want to consider when using Copa to patch images. Remember that these are suggestions that may not fit into your workflow, but we think that staying as close as possible to these practices offers the best experience with Copa.","source":"@site/docs/best-practices.md","sourceDirName":".","slug":"/best-practices","permalink":"/copacetic/website/next/best-practices","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Tagging Guidelines"},"sidebar":"sidebar","previous":{"title":"Quick Start","permalink":"/copacetic/website/next/quick-start"},"next":{"title":"Troubleshooting","permalink":"/copacetic/website/next/troubleshooting"}}');var s=n(4848),a=n(8453);const o={title:"Tagging Guidelines"},c=void 0,d={},r=[{value:"Tagging",id:"tagging",level:2},{value:"Static Incremental Tags",id:"static-incremental-tags",level:3},{value:"Dynamic Tags",id:"dynamic-tags",level:3},{value:"Dependabot",id:"dependabot",level:3}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"There are some patterns and practices you may want to consider when using Copa to patch images. Remember that these are suggestions that may not fit into your workflow, but we think that staying as close as possible to these practices offers the best experience with Copa."}),"\n",(0,s.jsx)(t.h2,{id:"tagging",children:"Tagging"}),"\n",(0,s.jsx)(t.p,{children:"There are a couple possible patterns that you could follow when tagging patched images."}),"\n",(0,s.jsx)(t.h3,{id:"static-incremental-tags",children:"Static Incremental Tags"}),"\n",(0,s.jsxs)(t.p,{children:["The first approach you could take is incrementing a number you append to the end of an image tag. For example, if you have an image tagged ",(0,s.jsx)(t.code,{children:"nginx:1.24.0"}),", following patches would be tagged as ",(0,s.jsx)(t.code,{children:"nginx:1.24.0-1"}),", ",(0,s.jsx)(t.code,{children:"nginx:1.24.0-2"}),", ",(0,s.jsx)(t.code,{children:"nginx:1.24.0-3"}),", and so on."]}),"\n",(0,s.jsx)(t.p,{children:"With this pattern you are always explicitly aware of the patch state of the image you are using. The downside is that dependabot is currently unable bump to patched images from unmodified images or bump from one patched image to the next."}),"\n",(0,s.jsx)(t.h3,{id:"dynamic-tags",children:"Dynamic Tags"}),"\n",(0,s.jsxs)(t.p,{children:["Another option is a static tag that is continually reused as new patches are applied. For example, you could have an initial unmodified image that you've tagged ",(0,s.jsx)(t.code,{children:"nginx:1.24.0-0"})," (in this case the ",(0,s.jsx)(t.code,{children:"-0"})," at the end helps identify the base unpatched image). All following patched images are then tagged as ",(0,s.jsx)(t.code,{children:"nginx:1.24.0"}),". You then know that the one tagged image always has the latest patches applied."]}),"\n",(0,s.jsxs)(t.p,{children:["This method makes it easy to continually consume the latest patched version of an image, but does contain some tradeoffs. First is that without pinning, image digests could change causing unpredictable behavior. Secondly, if an ",(0,s.jsx)(t.code,{children:"ImagePullPolicy"})," is set to ",(0,s.jsx)(t.code,{children:"IfNotPresent"}),", newly patched images would not be pulled since the tag hasn't changed."]}),"\n",(0,s.jsx)(t.h3,{id:"dependabot",children:"Dependabot"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://docs.github.com/en/code-security/dependabot",children:"Dependabot"})," can create PRs to update image versions to Copa patched versions."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["By default, if no update type is specified, Dependabot will be able to bump from a non-revision version to a revisioned version of an image if it exists. For example from ",(0,s.jsx)(t.code,{children:"1.2.3"})," -> ",(0,s.jsx)(t.code,{children:"1.2.3-1"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["If update type is restricted to patch only, the version would be updated to the patched version unless a minor version exists. For example, ",(0,s.jsx)(t.code,{children:"1.2.3"})," would be updated to ",(0,s.jsx)(t.code,{children:"1.2.3-1"})," and keep bumping revisions (",(0,s.jsx)(t.code,{children:"1.2.3-1 -> 1.2.3-2"})," etc.) over ",(0,s.jsx)(t.code,{children:"1.3.0"})," or ",(0,s.jsx)(t.code,{children:"2.0"}),". If ",(0,s.jsx)(t.code,{children:"1.2.4"})," exists, however, it would be updated to ",(0,s.jsx)(t.code,{children:"1.2.4"})," instead."]}),"\n",(0,s.jsxs)(t.li,{children:["If patched at build time, Dependabot should pick up the revision of the patch version (",(0,s.jsx)(t.code,{children:"1.2.3-2"})," -> ",(0,s.jsx)(t.code,{children:"1.2.4"})," -> ",(0,s.jsx)(t.code,{children:"1.2.4-1"}),") to minimize regressions."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>c});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);
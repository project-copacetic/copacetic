"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1108],{9702:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"multiplatform-patching","title":"Multi-Platform Patching","description":"Copa also supports patching multi-platform container images, streamlining the process of securing applications deployed across diverse hardware platforms. This guide explains how Copa handles multi-platform images and how you can use this feature.","source":"@site/docs/multiplatform-patching.md","sourceDirName":".","slug":"/multiplatform-patching","permalink":"/copacetic/website/next/multiplatform-patching","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Multi-Platform Patching"},"sidebar":"sidebar","previous":{"title":"Scanner Plugins","permalink":"/copacetic/website/next/scanner-plugins"},"next":{"title":"Contributing","permalink":"/copacetic/website/next/contributing"}}');var r=n(4848),a=n(8453);const s={title:"Multi-Platform Patching"},l=void 0,o={},c=[{value:"Usage",id:"usage",level:2},{value:"Method 1: Report-based Multi-Platform Patching",id:"method-1-report-based-multi-platform-patching",level:3},{value:"Create vulnerability reports for multi-platform images",id:"create-vulnerability-reports-for-multi-platform-images",level:4},{value:"Patching with Reports",id:"patching-with-reports",level:4},{value:"Method 2: Update all outdated packages",id:"method-2-update-all-outdated-packages",level:3},{value:"Valid Platform Values",id:"valid-platform-values",level:4},{value:"Key Flags for Multi-Platform Patching",id:"key-flags-for-multi-platform-patching",level:2},{value:"Things to Keep in Mind",id:"things-to-keep-in-mind",level:3},{value:"Emulation and QEMU for Cross-Platform Patching \u2699\ufe0f",id:"emulation-and-qemu-for-cross-platform-patching-\ufe0f",level:2},{value:"Why Emulation is Needed",id:"why-emulation-is-needed",level:3},{value:"Setting up QEMU",id:"setting-up-qemu",level:3}];function d(e){const i={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"Copa also supports patching multi-platform container images, streamlining the process of securing applications deployed across diverse hardware platforms. This guide explains how Copa handles multi-platform images and how you can use this feature."}),"\n",(0,r.jsx)(i.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(i.p,{children:"Similar to patching single architecture images, Copa supports two ways to patch multi-platform container images:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Report-based patching"}),": Use the ",(0,r.jsx)(i.code,{children:"--report"})," flag pointing to a directory containing platform-specific vulnerability reports. This is the traditional approach that patches only platforms that exist and have respective reports."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Update all outdated packages"}),": When report flag is omitted, Copa detects if it is a manifest list and patches oudated packages across all platforms. Use the optional ",(0,r.jsx)(i.code,{children:"--platform"})," flag to specify which platforms to patch."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"method-1-report-based-multi-platform-patching",children:"Method 1: Report-based Multi-Platform Patching"}),"\n",(0,r.jsx)(i.p,{children:"This method uses vulnerability reports to determine which platforms and vulnerabilities to patch."}),"\n",(0,r.jsx)(i.h4,{id:"create-vulnerability-reports-for-multi-platform-images",children:"Create vulnerability reports for multi-platform images"}),"\n",(0,r.jsxs)(i.p,{children:["Before you can patch a multi-platform image, you need to generate vulnerability reports for each platform architecture you wish to patch. You can do this using ",(0,r.jsx)(i.code,{children:"trivy"})," using ",(0,r.jsx)(i.code,{children:"--platform"})," flag to specify the architecture. Below is an example of how to generate vulnerability reports for a multi-platform image like ",(0,r.jsx)(i.code,{children:"nginx:1.25.0"}),"."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"export IMAGE=docker.io/library/nginx:1.25.0 # Replace with your multi-platform image\n\nmkdir -p reports\n\ntrivy image --vuln-type os --scanners vuln --ignore-unfixed \\\n  -f json -o reports/amd64.json \\\n  --platform linux/amd64 $IMAGE\ntrivy image --vuln-type os --scanners vuln --ignore-unfixed \\\n  -f json -o reports/arm64.json \\\n  --platform linux/arm64 $IMAGE\n"})}),"\n",(0,r.jsxs)(i.p,{children:["This will create two JSON files in the ",(0,r.jsx)(i.code,{children:"reports"})," directory, one for each architecture (",(0,r.jsx)(i.code,{children:"amd64"})," and ",(0,r.jsx)(i.code,{children:"arm64"}),")."]}),"\n",(0,r.jsx)(i.h4,{id:"patching-with-reports",children:"Patching with Reports"}),"\n",(0,r.jsxs)(i.p,{children:["To patch a multi-platform image using vulnerability reports, use the ",(0,r.jsx)(i.code,{children:"copa patch"})," command with the ",(0,r.jsx)(i.code,{children:"--image"})," flag to specify the multi-platform image, the ",(0,r.jsx)(i.code,{children:"--report"})," flag to point to the directory containing your vulnerability reports, and optionally a ",(0,r.jsx)(i.code,{children:"--tag"})," for the final patched image."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"copa patch \\\n  --image $IMAGE \\\n  --report reports\n"})}),"\n",(0,r.jsx)(i.h3,{id:"method-2-update-all-outdated-packages",children:"Method 2: Update all outdated packages"}),"\n",(0,r.jsxs)(i.p,{children:["To patch a multi-platform across all platforms and update all outdated packages to latest, use the ",(0,r.jsx)(i.code,{children:"copa patch"})," command with the ",(0,r.jsx)(i.code,{children:"--image"})," flag to specify the multi-platform image, and omit the ",(0,r.jsx)(i.code,{children:"--report"})," flag."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"copa patch \\\n  --image $IMAGE \\\n"})}),"\n",(0,r.jsxs)(i.p,{children:["To filter only specific platforms to patch, provide them with the ",(0,r.jsx)(i.code,{children:"--platform"})," flag."]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"copa patch \\\n  --image $IMAGE \\\n   --platform=linux/amd64,linux/arm64\n"})}),"\n",(0,r.jsx)(i.h4,{id:"valid-platform-values",children:"Valid Platform Values"}),"\n",(0,r.jsxs)(i.p,{children:["The ",(0,r.jsx)(i.code,{children:"--platform"})," flag accepts the following values:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/amd64"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/arm64"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/riscv64"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/ppc64le"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/s390x"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/386"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/arm/v7"})}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsx)(i.code,{children:"linux/arm/v6"})}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"You can specify multiple platforms by separating them with commas."}),"\n",(0,r.jsx)(i.h2,{id:"key-flags-for-multi-platform-patching",children:"Key Flags for Multi-Platform Patching"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--image <image_name>"}),": The multi-platform container image to patch."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--report <directory_path>"})," (optional): Specifies the directory containing platform-specific vulnerability reports. When provided, only platforms with reports are patched."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--platform <platform_list>"})," (optional): Comma-separated list of platforms to patch (e.g., ",(0,r.jsx)(i.code,{children:"linux/amd64,linux/arm64"}),"). Only available when ",(0,r.jsx)(i.code,{children:"--report"})," is not used. If not specified, all platforms are patched."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--tag <final_tag>"})," (optional): The tag for the final, reassembled multi-platform manifest (e.g., ",(0,r.jsx)(i.code,{children:"1.0-patched"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--push"})," (optional): If included, Copa pushes the final multi-platform manifest to the registry."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"--ignore-errors"})," (optional, default: ",(0,r.jsx)(i.code,{children:"false"}),"): When ",(0,r.jsx)(i.code,{children:"false"})," (default), Copa warns about errors and fails if any platform encounters an error. When ",(0,r.jsx)(i.code,{children:"true"}),", Copa warns about errors but continues processing other platforms."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"things-to-keep-in-mind",children:"Things to Keep in Mind"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Automatic platform detection"}),": Copa automatically detects whether an image is multi-platform (manifest list) or single-platform and handles them accordingly."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Report vs. platform flags"}),": The ",(0,r.jsx)(i.code,{children:"--platform"})," flag is only available when not using ",(0,r.jsx)(i.code,{children:"--report"}),". When using ",(0,r.jsx)(i.code,{children:"--report"}),", platforms are determined by the reports available."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Platform preservation"}),": When using ",(0,r.jsx)(i.code,{children:"--platform"}),", only specified platforms are patched; others are preserved unchanged in the final manifest."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"No local storage for unspecified platforms"}),": If ",(0,r.jsx)(i.code,{children:"--push"})," is not specified, the individual patched images will be saved locally, but preserved platforms will only exist in the registry."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Single-platform fallback"}),": If you don't provide a ",(0,r.jsx)(i.code,{children:"--report"})," directory and don't use ",(0,r.jsx)(i.code,{children:"--platform"}),", Copa will detect if the image is single-platform and patch only that platform."]}),"\n"]}),"\n",(0,r.jsxs)(i.admonition,{type:"note",children:[(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Report-based vs. Platform-based patching:"})}),(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["When using ",(0,r.jsx)(i.code,{children:"--report"}),", Copa copies over unpatched platforms as a passthrough - only platforms with vulnerability reports are patched, while other platforms remain unchanged in the final multi-platform image."]}),"\n",(0,r.jsxs)(i.li,{children:["When using ",(0,r.jsx)(i.code,{children:"--platform"}),", only the specified platforms are patched, and others are preserved unchanged."]}),"\n",(0,r.jsx)(i.li,{children:"When using neither flag, Copa patches all available platforms if the image is multi-platform."}),"\n"]})]}),"\n",(0,r.jsx)(i.admonition,{type:"warning",children:(0,r.jsx)(i.p,{children:"Build attestations, signatures, and OCI referrers from the original image are not preserved or copied to the patched image."})}),"\n",(0,r.jsx)(i.hr,{}),"\n",(0,r.jsx)(i.h2,{id:"emulation-and-qemu-for-cross-platform-patching-\ufe0f",children:"Emulation and QEMU for Cross-Platform Patching \u2699\ufe0f"}),"\n",(0,r.jsxs)(i.p,{children:["When patching an image for an architecture different from your host machine's architecture (e.g., patching an ",(0,r.jsx)(i.code,{children:"arm64"})," image on an ",(0,r.jsx)(i.code,{children:"amd64"})," machine), Copa relies on ",(0,r.jsx)(i.strong,{children:"emulation"}),". This is often necessary for multi-platform image patching, as you might not have native hardware for every architecture you intend to patch."]}),"\n",(0,r.jsxs)(i.p,{children:["Copa leverages ",(0,r.jsx)(i.strong,{children:"BuildKit"}),", which in turn can use ",(0,r.jsx)(i.strong,{children:"QEMU"})," for emulation. QEMU is a generic and open-source machine emulator and virtualizer. When BuildKit detects that it needs to execute binaries for a foreign architecture, it can use QEMU user-mode emulation to run those commands."]}),"\n",(0,r.jsx)(i.h3,{id:"why-emulation-is-needed",children:"Why Emulation is Needed"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Running Package Managers:"})," To apply patches, Copa needs to execute the package manager (like ",(0,r.jsx)(i.code,{children:"apk"}),", ",(0,r.jsx)(i.code,{children:"apt"}),", ",(0,r.jsx)(i.code,{children:"yum"}),") ",(0,r.jsx)(i.em,{children:"inside"})," the environment of the target image's architecture. If you're on an ",(0,r.jsx)(i.code,{children:"amd64"})," host trying to patch an ",(0,r.jsx)(i.code,{children:"arm64"})," image, the ",(0,r.jsx)(i.code,{children:"arm64"})," package manager won't run natively. QEMU bridges this gap."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Ensuring Correctness:"})," Emulation helps ensure that the patches are applied in an environment that closely mirrors the target architecture, reducing the chances of incompatibilities."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"setting-up-qemu",children:"Setting up QEMU"}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Docker Desktop (macOS and Windows) comes pre-configured with QEMU emulation support and requires no additional setup."})}),"\n",(0,r.jsxs)(i.p,{children:["For Linux hosts or when using BuildKit outside of Docker Desktop, your host system  (where the ",(0,r.jsx)(i.code,{children:"copa"})," command and BuildKit daemon are running) needs to have QEMU static binaries registered with the kernel's ",(0,r.jsx)(i.code,{children:"binfmt_misc"})," handler. This allows the kernel to automatically invoke QEMU when it encounters a binary for a foreign architecture."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Installation Steps (Linux/Non-Docker Desktop environments):"})}),"\n",(0,r.jsxs)(i.p,{children:["One way to set this up, especially in Dockerized environments or on Linux hosts, is to use the ",(0,r.jsx)(i.code,{children:"multiarch/qemu-user-static"})," image:"]}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsxs)(i.strong,{children:["Ensure your kernel supports ",(0,r.jsx)(i.code,{children:"binfmt_misc"}),":"]})," Most modern Linux kernels do."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Register QEMU handlers:"})," You can do this by running the ",(0,r.jsx)(i.code,{children:"multiarch/qemu-user-static"})," Docker image with privileged mode:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>l});var t=n(6540);const r={},a=t.createContext(r);function s(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);
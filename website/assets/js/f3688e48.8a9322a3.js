"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5305],{4998(e,i,t){t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"multiplatform-patching","title":"Multi-Platform Patching","description":"This guide covers Copa\'s multi-platform patching capabilities for securing applications across diverse hardware platforms.","source":"@site/versioned_docs/version-v0.13.x/multiplatform-patching.md","sourceDirName":".","slug":"/multiplatform-patching","permalink":"/copacetic/website/multiplatform-patching","draft":false,"unlisted":false,"tags":[],"version":"v0.13.x","frontMatter":{"title":"Multi-Platform Patching"},"sidebar":"sidebar","previous":{"title":"Bulk Image Patching","permalink":"/copacetic/website/bulk-image-patching"},"next":{"title":"Contributing","permalink":"/copacetic/website/contributing"}}');var r=t(4848),l=t(8453);const s={title:"Multi-Platform Patching"},a=void 0,c={},o=[{value:"Overview",id:"overview",level:2},{value:"Supported Architectures",id:"supported-architectures",level:3},{value:"Multi-Platform Patching Strategies",id:"multi-platform-patching-strategies",level:2},{value:"Report-Based Patching",id:"report-based-patching",level:3},{value:"Platform-Selective Patching",id:"platform-selective-patching",level:3},{value:"Comprehensive Patching",id:"comprehensive-patching",level:3},{value:"Multi-Platform Command Reference",id:"multi-platform-command-reference",level:2},{value:"Platform-Specific Flags",id:"platform-specific-flags",level:3},{value:"Multi-Platform Behavior",id:"multi-platform-behavior",level:2},{value:"Understanding the Results",id:"understanding-the-results",level:2},{value:"Cross-Platform Emulation Setup",id:"cross-platform-emulation-setup",level:2},{value:"Why Emulation is Required",id:"why-emulation-is-required",level:3},{value:"Package Manager Execution",id:"package-manager-execution",level:4},{value:"Architecture Compatibility",id:"architecture-compatibility",level:4},{value:"Setup Requirements",id:"setup-requirements",level:3},{value:"Docker Desktop Users (macOS/Windows)",id:"docker-desktop-users-macoswindows",level:4},{value:"Linux",id:"linux",level:4}];function d(e){const i={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"This guide covers Copa's multi-platform patching capabilities for securing applications across diverse hardware platforms."}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.a,{href:"https://docs.docker.com/build/building/multi-platform/",children:"Multi-platform images"})," contain multiple platform-specific variants of the same application. Copa can automatically detect and patch these images across all supported platforms or target specific architectures based on your needs."]}),"\n",(0,r.jsx)(i.h3,{id:"supported-architectures",children:"Supported Architectures"}),"\n",(0,r.jsx)(i.p,{children:"Copa supports patching the following platforms:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Platform"}),(0,r.jsx)(i.th,{children:"Description"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/amd64"})}),(0,r.jsx)(i.td,{children:"64-bit x86 (Intel/AMD)"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/arm64"})}),(0,r.jsx)(i.td,{children:"64-bit ARM (Apple Silicon, AWS Graviton)"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/arm/v7"})}),(0,r.jsx)(i.td,{children:"32-bit ARM v7"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/arm/v6"})}),(0,r.jsx)(i.td,{children:"32-bit ARM v6"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/386"})}),(0,r.jsx)(i.td,{children:"32-bit x86"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/ppc64le"})}),(0,r.jsx)(i.td,{children:"PowerPC 64-bit Little Endian"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/s390x"})}),(0,r.jsx)(i.td,{children:"IBM System z"})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"linux/riscv64"})}),(0,r.jsx)(i.td,{children:"64-bit RISC-V"})]})]})]}),"\n",(0,r.jsx)(i.admonition,{type:"note",children:(0,r.jsxs)(i.p,{children:["Any platform not listed above (such as ",(0,r.jsx)(i.code,{children:"windows/amd64"}),") is not supported by Copa for patching. However, they'll be always be preserved as is if they exist in the original manifest."]})}),"\n",(0,r.jsx)(i.h2,{id:"multi-platform-patching-strategies",children:"Multi-Platform Patching Strategies"}),"\n",(0,r.jsx)(i.p,{children:"Copa offers several approaches for multi-platform patching, each optimized for different use cases:"}),"\n",(0,r.jsx)(i.h3,{id:"report-based-patching",children:"Report-Based Patching"}),"\n",(0,r.jsx)(i.p,{children:"Generate platform-specific vulnerability reports and patch only affected platforms:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:'# Generate reports for specific platforms\nexport IMAGE=docker.io/library/nginx:1.25.0\nmkdir -p reports\n\n# Create platform-specific reports\nexport PLATFORMS="linux/amd64 linux/arm64"\nfor platform in $PLATFORMS; do\n  arch=$(echo $platform | cut -d\'/\' -f2 | sed \'s/\\//-/g\')\n  echo "Scanning $platform..."\n  trivy image --vuln-type os --scanners vuln --ignore-unfixed \\\n    -f json -o reports/${arch}.json --image-src remote --platform $platform $IMAGE || \\\n    echo "Warning: Failed to scan $platform"\ndone\n\n# Patch only platforms with reports\ncopa patch --image $IMAGE --report reports --tag nginx:1.25.0-patched\n'})}),"\n",(0,r.jsx)(i.h3,{id:"platform-selective-patching",children:"Platform-Selective Patching"}),"\n",(0,r.jsx)(i.p,{children:"Target specific platforms:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"# Patch only linux/amd64 and linux/arm64 platforms\n# Rest of the platforms will be preserved unchanged\ncopa patch --image $IMAGE \\\n  --platform linux/amd64,linux/arm64 \\\n  --tag nginx:1.25.0-patched\n\n# Patch all available platforms (default behavior)\ncopa patch --image $IMAGE --tag nginx:1.25.0-patched\n"})}),"\n",(0,r.jsx)(i.h3,{id:"comprehensive-patching",children:"Comprehensive Patching"}),"\n",(0,r.jsx)(i.p,{children:"Update all platforms with the latest patches:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"# Patch all platforms in the manifest list\ncopa patch --image $IMAGE --tag nginx:1.25.0-patched\n"})}),"\n",(0,r.jsx)(i.h2,{id:"multi-platform-command-reference",children:"Multi-Platform Command Reference"}),"\n",(0,r.jsx)(i.h3,{id:"platform-specific-flags",children:"Platform-Specific Flags"}),"\n",(0,r.jsx)(i.p,{children:"These flags are essential for multi-platform patching:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Flag"}),(0,r.jsx)(i.th,{children:"Description"}),(0,r.jsx)(i.th,{children:"Example"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--platform"})}),(0,r.jsx)(i.td,{children:"Specifies which platforms to patch from manifest list"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--platform linux/amd64,linux/arm64"})})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--report"})}),(0,r.jsx)(i.td,{children:"Directory with platform-specific vulnerability reports"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--report ./platform-reports/"})})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--ignore-errors"})}),(0,r.jsx)(i.td,{children:"Continue patching other platforms if one fails"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--ignore-errors"})})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--push"})}),(0,r.jsx)(i.td,{children:"Push all manifests and index/manifest list to registry"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--push"})})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--oci-dir"})}),(0,r.jsx)(i.td,{children:"Export multi-platform index/manifest as OCI layout directory"}),(0,r.jsx)(i.td,{children:(0,r.jsx)(i.code,{children:"--oci-dir ./output-directory"})})]})]})]}),"\n",(0,r.jsx)(i.h2,{id:"multi-platform-behavior",children:"Multi-Platform Behavior"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Automatic platform detection"}),": Copa automatically detects whether an image is multi-platform (Docker manifest list or OCI Index) or single-platform and handles them accordingly."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Report vs. platform flags"}),": The ",(0,r.jsx)(i.code,{children:"--platform"})," flag is only available when not using ",(0,r.jsx)(i.code,{children:"--report"}),". When using ",(0,r.jsx)(i.code,{children:"--report"}),", platforms are determined by the reports available."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Platform preservation"}),": When using ",(0,r.jsx)(i.code,{children:"--platform"}),", only specified platforms are patched; others are preserved unchanged in the final manifest."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"OCI layout export"}),": The ",(0,r.jsx)(i.code,{children:"--oci-dir"})," flag creates a local OCI Image Layout directory structure for the patched manifest. Use when opting to not push to registry. ",(0,r.jsx)(i.code,{children:"--push"})," and ",(0,r.jsx)(i.code,{children:"--oci-dir"})," cannot be used together."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"No local storage for unspecified platforms"}),": If ",(0,r.jsx)(i.code,{children:"--push"})," is not specified, the individual patched images will be saved locally, but preserved platforms will only exist in the registry."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Single-platform fallback"}),": If you don't provide a ",(0,r.jsx)(i.code,{children:"--report"})," directory and don't use ",(0,r.jsx)(i.code,{children:"--platform"}),", Copa will detect if the image is single-platform and patch only that platform."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(i.admonition,{type:"note",children:[(0,r.jsx)(i.p,{children:(0,r.jsx)(i.strong,{children:"Report-based vs. Platform-based patching:"})}),(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:["When using ",(0,r.jsx)(i.code,{children:"--report"}),", Copa copies over unpatched platforms as a passthrough - only platforms with vulnerability reports are patched, while other platforms remain unchanged in the final multi-platform image."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:["When using ",(0,r.jsx)(i.code,{children:"--platform"}),", only the specified platforms are patched, and others are preserved unchanged."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsx)(i.p,{children:"When using neither flag, Copa patches all available platforms if the image is multi-platform."}),"\n"]}),"\n"]})]}),"\n",(0,r.jsx)(i.admonition,{type:"warning",children:(0,r.jsx)(i.p,{children:"Build attestations, signatures, and OCI referrers from the original image are not preserved or copied to the patched image."})}),"\n",(0,r.jsx)(i.h2,{id:"understanding-the-results",children:"Understanding the Results"}),"\n",(0,r.jsx)(i.p,{children:"After a multi-platform run, Copa prints a tabular summary so you can quickly see what happened for each platform.\nA typical example looks like (including a failure case):"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-text",children:"Multi-arch patch summary:\nPLATFORM        STATUS   REFERENCE                                        MESSAGE\nlinux/amd64     Patched  docker.io/library/nginx:1.27.1-patched-amd64     Successfully patched image (linux/amd64)\nlinux/arm/v7    Patched  docker.io/library/nginx:1.27.1-patched-arm-v7    Successfully patched image (linux/arm/v7)\nlinux/arm64     Patched  docker.io/library/nginx:1.27.1-patched-arm64     Successfully patched image (linux/arm64)\nlinux/386       Error    -                                                Emulation is not enabled for platform linux/386\nlinux/mips64le  Patched  docker.io/library/nginx:1.27.1-patched-mips64le  Successfully patched image (linux/mips64le)\nlinux/ppc64le   Patched  docker.io/library/nginx:1.27.1-patched-ppc64le   Successfully patched image (linux/ppc64le)\nlinux/s390x     Patched  docker.io/library/nginx:1.27.1-patched-s390x     Successfully patched image (linux/s390x)\n"})}),"\n",(0,r.jsxs)(i.p,{children:["In this example, the linux/386 platform failed with Error because QEMU emulation is not enabled on the host.\nIf you see a similar error, follow the steps in ",(0,r.jsx)(i.a,{href:"#cross-platform-emulation-setup",children:"Cross-Platform Emulation Setup"})," to enable emulation and then rerun the patch."]}),"\n",(0,r.jsx)(i.h2,{id:"cross-platform-emulation-setup",children:"Cross-Platform Emulation Setup"}),"\n",(0,r.jsx)(i.p,{children:"When patching images for architectures different from your host machine (e.g., patching ARM64 images on an AMD64 host), Copa uses QEMU emulation through BuildKit."}),"\n",(0,r.jsx)(i.h3,{id:"why-emulation-is-required",children:"Why Emulation is Required"}),"\n",(0,r.jsx)(i.h4,{id:"package-manager-execution",children:"Package Manager Execution"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Copa executes package managers (",(0,r.jsx)(i.code,{children:"apt"}),", ",(0,r.jsx)(i.code,{children:"yum"}),", ",(0,r.jsx)(i.code,{children:"apk"}),", ",(0,r.jsx)(i.code,{children:"zypper"}),") inside the target architecture environment"]}),"\n",(0,r.jsx)(i.li,{children:"Native binaries for foreign architectures cannot run without emulation"}),"\n",(0,r.jsx)(i.li,{children:"QEMU provides transparent binary translation"}),"\n"]}),"\n",(0,r.jsx)(i.h4,{id:"architecture-compatibility",children:"Architecture Compatibility"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Ensures patches are applied correctly for the target architecture"}),"\n",(0,r.jsx)(i.li,{children:"Prevents compatibility issues between different instruction sets"}),"\n",(0,r.jsx)(i.li,{children:"Maintains image integrity across platforms"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"setup-requirements",children:"Setup Requirements"}),"\n",(0,r.jsx)(i.h4,{id:"docker-desktop-users-macoswindows",children:"Docker Desktop Users (macOS/Windows)"}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"No setup required"})," - QEMU emulation is pre-configured and ready to use."]}),"\n",(0,r.jsx)(i.h4,{id:"linux",children:"Linux"}),"\n",(0,r.jsxs)(i.p,{children:["QEMU static binaries must be registered with the kernel's ",(0,r.jsx)(i.code,{children:"binfmt_misc"})," handler:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-bash",children:"# Install QEMU emulation support\ndocker run --privileged --rm tonistiigi/binfmt --install all\n\n# Verify installation\nls /proc/sys/fs/binfmt_misc/qemu-*\n"})}),"\n",(0,r.jsxs)(i.p,{children:["For more details, see ",(0,r.jsx)(i.a,{href:"https://docs.docker.com/build/building/multi-platform/#qemu",children:"Docker's QEMU documentation"}),"."]})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453(e,i,t){t.d(i,{R:()=>s,x:()=>a});var n=t(6540);const r={},l=n.createContext(r);function s(e){const i=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(l.Provider,{value:i},e.children)}}}]);
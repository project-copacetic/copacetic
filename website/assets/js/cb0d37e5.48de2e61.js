"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1108],{9702:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"multiplatform-patching","title":"Multi-Platform Patching","description":"Copa also supports patching multi-platform container images, streamlining the process of securing applications deployed across diverse hardware platforms. This guide explains how Copa handles multi-platform images and how you can use this feature.","source":"@site/docs/multiplatform-patching.md","sourceDirName":".","slug":"/multiplatform-patching","permalink":"/copacetic/website/next/multiplatform-patching","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Multi-Platform Patching"},"sidebar":"sidebar","previous":{"title":"Scanner Plugins","permalink":"/copacetic/website/next/scanner-plugins"},"next":{"title":"Contributing","permalink":"/copacetic/website/next/contributing"}}');var r=i(4848),a=i(8453);const o={title:"Multi-Platform Patching"},s=void 0,l={},c=[{value:"Usage",id:"usage",level:2},{value:"Create vulnerability reports for multi-platform images",id:"create-vulnerability-reports-for-multi-platform-images",level:3},{value:"Patching Multi-Platform Images",id:"patching-multi-platform-images",level:3},{value:"Things to Keep in Mind",id:"things-to-keep-in-mind",level:3},{value:"Emulation and QEMU for Cross-Platform Patching \u2699\ufe0f",id:"emulation-and-qemu-for-cross-platform-patching-\ufe0f",level:2},{value:"Why Emulation is Needed",id:"why-emulation-is-needed",level:3},{value:"Setting up QEMU",id:"setting-up-qemu",level:3}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Copa also supports patching multi-platform container images, streamlining the process of securing applications deployed across diverse hardware platforms. This guide explains how Copa handles multi-platform images and how you can use this feature."}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(n.p,{children:["To patch a multi-platform image, you can use the ",(0,r.jsx)(n.code,{children:"copa patch"})," command with the ",(0,r.jsx)(n.code,{children:"--report"})," flag pointing to a directory (which tells Copa this will be a multi-platform patch) along with flags to specify your image, and desired output tag."]}),"\n",(0,r.jsx)(n.h3,{id:"create-vulnerability-reports-for-multi-platform-images",children:"Create vulnerability reports for multi-platform images"}),"\n",(0,r.jsxs)(n.p,{children:["Before you can patch a multi-platform image, you need to generate vulnerability reports for each platform architecture. You can do this using ",(0,r.jsx)(n.code,{children:"trivy"})," using ",(0,r.jsx)(n.code,{children:"--platform"})," flag to specify the architecture. Below is an example of how to generate vulnerability reports for a multi-platform image like ",(0,r.jsx)(n.code,{children:"nginx:1.25.0"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"export IMAGE=docker.io/library/nginx:1.25.0 # Replace with your multi-platform image\n\nmkdir -p reports\n\ntrivy image --vuln-type os --scanners vuln --ignore-unfixed \\\n  -f json -o reports/amd64.json \\\n  --platform linux/amd64 $IMAGE\ntrivy image --vuln-type os --scanners vuln --ignore-unfixed \\\n  -f json -o reports/arm64.json \\\n  --platform linux/arm64 $IMAGE\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This will create two JSON files in the ",(0,r.jsx)(n.code,{children:"reports"})," directory, one for each architecture (",(0,r.jsx)(n.code,{children:"amd64"})," and ",(0,r.jsx)(n.code,{children:"arm64"}),")."]}),"\n",(0,r.jsx)(n.h3,{id:"patching-multi-platform-images",children:"Patching Multi-Platform Images"}),"\n",(0,r.jsxs)(n.p,{children:["To patch a multi-platform image, you can use the ",(0,r.jsx)(n.code,{children:"copa patch"})," command with the ",(0,r.jsx)(n.code,{children:"--image"})," flag to specify the multi-platform image, the ",(0,r.jsx)(n.code,{children:"--report"})," flag to point to the directory containing your vulnerability reports, and optionally a ",(0,r.jsx)(n.code,{children:"--tag"})," for the final patched image."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"copa patch \\\n  --image $IMAGE \\\n  --report reports\n"})}),"\n",(0,r.jsx)(n.p,{children:"Key Flags for Multi-Platform Patching:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--report <directory_path>"}),": Specifies the directory containing platform-specific vulnerability reports."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--tag <final_tag>"})," (optional): The tag for the final, reassembled multi-platform manifest (e.g., ",(0,r.jsx)(n.code,{children:"1.0-patched"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--push"})," (optional): If included, Copa pushes the final multi-platform manifest to the registry."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"--ignore-errors"})," (optional, default: ",(0,r.jsx)(n.code,{children:"false"}),"): When ",(0,r.jsx)(n.code,{children:"false"})," (default), Copa warns about errors and fails if any platform encounters an error. When ",(0,r.jsx)(n.code,{children:"true"}),", Copa warns about errors but continues processing other platforms."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"things-to-keep-in-mind",children:"Things to Keep in Mind"}),"\n",(0,r.jsxs)(n.p,{children:["If you don't provide a ",(0,r.jsx)(n.code,{children:"--report"})," flag pointing to a directory, Copa will not perform multi-platform patching and will instead only patch the image for the architecture of the host machine."]}),"\n",(0,r.jsxs)(n.p,{children:["If ",(0,r.jsx)(n.code,{children:"--push"})," is not specified, the individual patched images will be saved locally, and you can push them to your registry later using ",(0,r.jsx)(n.code,{children:"docker push"})," and then ",(0,r.jsx)(n.code,{children:"docker manifest create/push"})," to create the multi-platform manifest."]}),"\n",(0,r.jsx)(n.admonition,{type:"note",children:(0,r.jsx)(n.p,{children:"Copa copies over unpatched platforms as a passthrough - only platforms with vulnerability reports are patched, while other platforms remain unchanged in the final multi-platform image."})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"Build attestations, signatures, and OCI referrers from the original image are not preserved or copied to the patched image."})}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"emulation-and-qemu-for-cross-platform-patching-\ufe0f",children:"Emulation and QEMU for Cross-Platform Patching \u2699\ufe0f"}),"\n",(0,r.jsxs)(n.p,{children:["When patching an image for an architecture different from your host machine's architecture (e.g., patching an ",(0,r.jsx)(n.code,{children:"arm64"})," image on an ",(0,r.jsx)(n.code,{children:"amd64"})," machine), Copa relies on ",(0,r.jsx)(n.strong,{children:"emulation"}),". This is often necessary for multi-platform image patching, as you might not have native hardware for every architecture you intend to patch."]}),"\n",(0,r.jsxs)(n.p,{children:["Copa leverages ",(0,r.jsx)(n.strong,{children:"BuildKit"}),", which in turn can use ",(0,r.jsx)(n.strong,{children:"QEMU"})," for emulation. QEMU is a generic and open-source machine emulator and virtualizer. When BuildKit detects that it needs to execute binaries for a foreign architecture, it can use QEMU user-mode emulation to run those commands."]}),"\n",(0,r.jsx)(n.h3,{id:"why-emulation-is-needed",children:"Why Emulation is Needed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Running Package Managers:"})," To apply patches, Copa needs to execute the package manager (like ",(0,r.jsx)(n.code,{children:"apk"}),", ",(0,r.jsx)(n.code,{children:"apt"}),", ",(0,r.jsx)(n.code,{children:"yum"}),") ",(0,r.jsx)(n.em,{children:"inside"})," the environment of the target image's architecture. If you're on an ",(0,r.jsx)(n.code,{children:"amd64"})," host trying to patch an ",(0,r.jsx)(n.code,{children:"arm64"})," image, the ",(0,r.jsx)(n.code,{children:"arm64"})," package manager won't run natively. QEMU bridges this gap."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ensuring Correctness:"})," Emulation helps ensure that the patches are applied in an environment that closely mirrors the target architecture, reducing the chances of incompatibilities."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"setting-up-qemu",children:"Setting up QEMU"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Docker Desktop (macOS and Windows) comes pre-configured with QEMU emulation support and requires no additional setup."})}),"\n",(0,r.jsxs)(n.p,{children:["For Linux hosts or when using BuildKit outside of Docker Desktop, your host system  (where the ",(0,r.jsx)(n.code,{children:"copa"})," command and BuildKit daemon are running) needs to have QEMU static binaries registered with the kernel's ",(0,r.jsx)(n.code,{children:"binfmt_misc"})," handler. This allows the kernel to automatically invoke QEMU when it encounters a binary for a foreign architecture."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Installation Steps (Linux/Non-Docker Desktop environments):"})}),"\n",(0,r.jsxs)(n.p,{children:["One way to set this up, especially in Dockerized environments or on Linux hosts, is to use the ",(0,r.jsx)(n.code,{children:"multiarch/qemu-user-static"})," image:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Ensure your kernel supports ",(0,r.jsx)(n.code,{children:"binfmt_misc"}),":"]})," Most modern Linux kernels do."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Register QEMU handlers:"})," You can do this by running the ",(0,r.jsx)(n.code,{children:"multiarch/qemu-user-static"})," Docker image with privileged mode:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"docker run --rm --privileged multiarch/qemu-user-static --reset -p yes\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>s});var t=i(6540);const r={},a=t.createContext(r);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);